<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>Ka's Blog</title>
        <description>Ka's Blog - Ka</description>
        <link></link>
        <atom:link href="" rel="self" type="application/rss+xml" />
        <lastBuildDate>Sun, 13 Aug 2017 14:20:30 +0800</lastBuildDate>
        <pubDate>Sun, 13 Aug 2017 14:20:30 +0800</pubDate>
        <ttl>60</ttl>


        <item>
                <title>InfoQ 文章 Hunting Java Concurrency Bugs</title>
                <description>&lt;p&gt;&lt;a title=&quot;http://www.infoq.com/articles/Hunting-Concurrency-Bugs-1&quot; href=&quot;http://www.infoq.com/articles/Hunting-Concurrency-Bugs-1&quot;&gt;http://www.infoq.com/articles/Hunting-Concurrency-Bugs-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;这篇文章很值得一读。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;主要讨论了openJDK（注意文中没有说明Oracle JDK也有相同问题）自身存在的问题，以及分析问题的艰辛过程。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;第一个问题是1.7.0_40 之前存在的多线程下造成livelock，jstack无响应。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;第二个问题是HashMap的OOM，多线程下操作引起循环指针在序列化的情况下出现OOM。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;这个问题出现后还好有个10G 的heapdump，文件太大不能工具直接分析，直接看文件分析可能是循环指针序列化造成的，尝试使用ObjectInputStream读出，但是由于其本机没有生产环境所有的类（造业），此路不通，最后通过unix的strings工具获得反序列化的字符串，得知是个hashmap。&lt;/p&gt;
&lt;p&gt;他们在本机尝试多线程操作hashmap引起崩溃，重现了问题。最后将hashmap改为java.util.concurrent.ConcurrentHashMap解决问题。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;评论中提到JCStress&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.oschina.net/translate/concurrency-torture-testing-your-code-within-the-java-memory-model&quot; href=&quot;http://www.oschina.net/translate/concurrency-torture-testing-your-code-within-the-java-memory-model&quot;&gt;http://www.oschina.net/translate/concurrency-torture-testing-your-code-within-the-java-memory-model&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/java/2014/12/09/infoq-e6-96-87-e7-ab-a0-hunting-java-concurrency-bugs.html</link>
                <guid>/java/2014/12/09/infoq-%e6%96%87%e7%ab%a0-hunting-java-concurrency-bugs</guid>
                <pubDate>Tue, 09 Dec 2014 01:27:24 +0800</pubDate>
        </item>

        <item>
                <title>OpenJDK 和Oracle JDK 的区别</title>
                <description>&lt;p&gt;这篇 &lt;a title=&quot;http://blog.sina.com.cn/s/blog_5cfd3adf0101a9db.html&quot; href=&quot;http://blog.sina.com.cn/s/blog_5cfd3adf0101a9db.html&quot;&gt;http://blog.sina.com.cn/s/blog_5cfd3adf0101a9db.html&lt;/a&gt; 文章讲了一些，但是不完全正确。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;参考&lt;a title=&quot;https://blogs.oracle.com/henrik/entry/moving_to_openjdk_as_the&quot; href=&quot;https://blogs.oracle.com/henrik/entry/moving_to_openjdk_as_the&quot;&gt;https://blogs.oracle.com/henrik/entry/moving_to_openjdk_as_the&lt;/a&gt; 这里&lt;/p&gt;
&lt;p&gt;Oracle 基于 OpenJDK 代码创建 Reference Implementation (RI)&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;Oracle&amp;#160; 创建RI 是基于BCL协议而openJDK是GPLv2&lt;/p&gt;
&lt;p&gt;具体Oracle的商业限制 要看&lt;a title=&quot;http://www.oracle.com/technetwork/java/javase/terms/products/index.html&quot; href=&quot;http://www.oracle.com/technetwork/java/javase/terms/products/index.html&quot;&gt;http://www.oracle.com/technetwork/java/javase/terms/products/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;BCL 在这里 &lt;a title=&quot;http://www.oracle.com/technetwork/java/javase/terms/license/index.html&quot; href=&quot;http://www.oracle.com/technetwork/java/javase/terms/license/index.html&quot;&gt;http://www.oracle.com/technetwork/java/javase/terms/license/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;哎妈太麻烦，现在linux系统上默认装的都是OpenJDK&lt;/p&gt;
&lt;p&gt;但是据说OpenJDK问题有点小多。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;一般的使用Oracle JDK并不违反什么商业限制：&lt;/p&gt;
&lt;p&gt;就我所知的JMX 用第三方查看器查看javax.management包下的或是自己开发的MBean是没有违反限制的 jvisualvm是第三方工具 jconsole是免费的；&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;但是Java Flight Recorder 和 Java Mission Control 却是要收费的，晕。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;参见：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blogs.oracle.com/henrik/entry/moving_to_openjdk_as_the&quot; href=&quot;https://blogs.oracle.com/henrik/entry/moving_to_openjdk_as_the&quot;&gt;https://blogs.oracle.com/henrik/entry/moving_to_openjdk_as_the&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://blog.sina.com.cn/s/blog_5cfd3adf0101a9db.html&quot; href=&quot;http://blog.sina.com.cn/s/blog_5cfd3adf0101a9db.html&quot;&gt;http://blog.sina.com.cn/s/blog_5cfd3adf0101a9db.html&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/java/2014/12/09/openjdk-e5-92-8coracle-jdk-e7-9a-84-e5-8c-ba-e5-88-ab.html</link>
                <guid>/java/2014/12/09/openjdk-%e5%92%8coracle-jdk-%e7%9a%84%e5%8c%ba%e5%88%ab</guid>
                <pubDate>Tue, 09 Dec 2014 01:12:46 +0800</pubDate>
        </item>

        <item>
                <title>JVM Heap最大内存限制</title>
                <description>&lt;p&gt;好久没写日志了&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;最近的项目陷入了hazelcast的巨坑之中，问题之一就是hazelcast的各种内存泄露，让我绞尽脑汁，最后大家商量没得办法，只好说服让客户每月重启一次，这样他们还不至于拿锤子锤你，然后加大JVM内存。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;先得确认一下jvm的内存限制：&lt;/p&gt;
&lt;p&gt;http://stackoverflow.com/questions/2093679/max-memory-for-64bit-java&lt;/p&gt;
&lt;p&gt;http://stackoverflow.com/questions/1434779/maximum-java-heap-size-of-a-32-bit-jvm-on-a-64-bit-os&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;32bit OS 1.2G就有些够呛&lt;/p&gt;
&lt;p&gt;64bit OS + 64bit JVM 理论上是2的64次方，人家试过1000G是没得问题的。&lt;/p&gt;
</description>
                <link>/java/2014/12/04/jvm-heap-e6-9c-80-e5-a4-a7-e5-86-85-e5-ad-98-e9-99-90-e5-88-b6.html</link>
                <guid>/java/2014/12/04/jvm-heap%e6%9c%80%e5%a4%a7%e5%86%85%e5%ad%98%e9%99%90%e5%88%b6</guid>
                <pubDate>Thu, 04 Dec 2014 20:35:57 +0800</pubDate>
        </item>

        <item>
                <title>IE 各版本测试</title>
                <description>&lt;p&gt;发现这个网站&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.modern.ie/zh-cn/virtualization-tools#downloads&quot; href=&quot;https://www.modern.ie/zh-cn/virtualization-tools#downloads&quot;&gt;https://www.modern.ie/zh-cn/virtualization-tools#downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;可以下载虚拟机测试各版本IE&lt;/p&gt;
</description>
                <link>/web/web%E5%89%8D%E7%AB%AF/2014/10/25/ie-e5-90-84-e7-89-88-e6-9c-ac-e6-b5-8b-e8-af-95.html</link>
                <guid>/web/web%E5%89%8D%E7%AB%AF/2014/10/25/ie-%e5%90%84%e7%89%88%e6%9c%ac%e6%b5%8b%e8%af%95</guid>
                <pubDate>Sat, 25 Oct 2014 01:37:36 +0800</pubDate>
        </item>

        <item>
                <title>屏蔽流氓站点taobao.114so.cn daohang.114so.cn 114so.cn</title>
                <description>&lt;p&gt;使用电（插入符）信真是很窝火，价格贵，速度一般，还动不动就来个DNS劫持，在网页上显示他们的广告，而且做得很隐蔽，普通用户还以为是别的网站的广告，我投诉几次，他们还装白痴，你投诉一次他们乖点，隔段又卷土重来。对于这样的垄断性流氓， 我等屁民有什么办法。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;今天Avasta报警，关于daohang.114so.cn的，让我吓了一跳，查了一下还是电（插入符）信的劫持，网上找到一个方法&lt;/p&gt;
&lt;p&gt;http://blog.sina.com.cn/s/blog_7557b5110101aqkf.html&lt;/p&gt;
&lt;p&gt;修改hosts文件&lt;/p&gt;
&lt;p&gt;C:\WINDOWS\system32\drivers\etc&lt;/p&gt;
&lt;p&gt;127.0.0.1 taobao.114so.cn&lt;br /&gt;
	127.0.0.1 daohang.114so.cn&lt;br /&gt;
	127.0.0.1&amp;nbsp;114so.cn&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;Mac下&lt;/p&gt;
&lt;pre&gt;/private/etc/hosts

mac下不需要重启, ping &lt;span style=&quot;font-family: Arial, Verdana, sans-serif;&quot;&gt;114so.cn测试结果为127.0.0.1就可以了&lt;/span&gt;&lt;/pre&gt;
</description>
                <link>/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/2014/08/11/e5-b1-8f-e8-94-bd-e6-b5-81-e6-b0-93-e7-ab-99-e7-82-b9taobao-114so-cn-daohang-114so-cn-114so-cn.html</link>
                <guid>/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/2014/08/11/%e5%b1%8f%e8%94%bd%e6%b5%81%e6%b0%93%e7%ab%99%e7%82%b9taobao-114so-cn-daohang-114so-cn-114so-cn</guid>
                <pubDate>Mon, 11 Aug 2014 20:16:41 +0800</pubDate>
        </item>

        <item>
                <title>InfoQ文章 介绍另一种开发ios程序的方式 使用RoboVM</title>
                <description>&lt;p&gt;InfoQ上文章 http://www.infoq.com/articles/unusual-ways-to-create-a-mobile-app&lt;/p&gt;
&lt;p&gt;这种使用RoboVM的方式真还是第一次听说，基于ROboVM可以使用Java系语言，需要在MacOS上使用Eclipse来将代码预编译为目标机器的字节码（&lt;span style=&quot;color: rgb(0, 0, 0); font-family: Arial, Helvetica, sans-serif; font-size: 14px; line-height: 21px;&quot;&gt;ahead-of-time compiler&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;大略看了一下，类型转换类似于jni方式，不过它自带是转换了一些IOS SDK的库。 &lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;如果是这样，还是直接用ObjectC吧或是Swift吧。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
                <link>/apple/java/2014/08/01/infoq-e6-96-87-e7-ab-a0-e4-bb-8b-e7-bb-8d-e5-8f-a6-e4-b8-80-e7-a7-8d-e5-bc-80-e5-8f-91ios-e7-a8-8b-e5-ba-8f-e7-9a-84-e6-96-b9-e5-bc-8f-e4-bd-bf-e7-94-a8robovm.html</link>
                <guid>/apple/java/2014/08/01/infoq%e6%96%87%e7%ab%a0-%e4%bb%8b%e7%bb%8d%e5%8f%a6%e4%b8%80%e7%a7%8d%e5%bc%80%e5%8f%91ios%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%96%b9%e5%bc%8f-%e4%bd%bf%e7%94%a8robovm</guid>
                <pubDate>Fri, 01 Aug 2014 15:27:07 +0800</pubDate>
        </item>

        <item>
                <title>Iterm2 打开后马上关闭的错误  argpath=login error=No such file or directory</title>
                <description>&lt;p&gt;这个主要是默认打开的tab（Profiles -&amp;gt; Genera-&amp;gt;defaultl -&amp;gt; Command）里使用了选择了Command，改为Login Shell就好了。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;参见：&lt;a title=&quot;http://apple.stackexchange.com/questions/50752/iterm2-terminals-close-immediately-with-argpath-login-error-no-such-file-or-dir&quot; href=&quot;http://apple.stackexchange.com/questions/50752/iterm2-terminals-close-immediately-with-argpath-login-error-no-such-file-or-dir&quot;&gt;http://apple.stackexchange.com/questions/50752/iterm2-terminals-close-immediately-with-argpath-login-error-no-such-file-or-dir&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/apple/2014/07/01/iterm2-e6-89-93-e5-bc-80-e5-90-8e-e9-a9-ac-e4-b8-8a-e5-85-b3-e9-97-ad-e7-9a-84-e9-94-99-e8-af-af-argpathlogin-errorno-such-file-or-directory.html</link>
                <guid>/apple/2014/07/01/iterm2-%e6%89%93%e5%bc%80%e5%90%8e%e9%a9%ac%e4%b8%8a%e5%85%b3%e9%97%ad%e7%9a%84%e9%94%99%e8%af%af-argpathlogin-errorno-such-file-or-directory</guid>
                <pubDate>Tue, 01 Jul 2014 16:38:35 +0800</pubDate>
        </item>

        <item>
                <title>virtualbox 下设置静态ip</title>
                <description>&lt;p&gt;这几天想在本机上建立一个mysql集群测试环境，结果死活安不上去，只好尝试安装多个ubuntu server系统到virtualbox上，但是发现要设置静态ip是如此之麻烦。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;具体参考:&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://coding4streetcred.com/blog/post/VirtualBox-Configuring-Static-IPs-for-VMs&quot; href=&quot;http://coding4streetcred.com/blog/post/VirtualBox-Configuring-Static-IPs-for-VMs&quot;&gt;http://coding4streetcred.com/blog/post/VirtualBox-Configuring-Static-IPs-for-VMs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;我按照上面的步骤，最后没发不起作用。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;对于无界面的ubuntu和其他linux系统，还得保证HostOnly 对应的网卡是开启的&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://bowerstudios.com/node/1015&quot; href=&quot;https://bowerstudios.com/node/1015&quot;&gt;https://bowerstudios.com/node/1015&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;一般eth0对应的是NAT网卡，所以eth1是HostOnly网卡。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;按照上面的步骤开启eth1，但是静态ip还是不行。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;最后我只好使用dhcp配置，怎么达到静态ip的效果呢？&lt;/p&gt;
&lt;p&gt;那就是将dhcp 的地址分配指定为一个地址&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kazge.com/wp-content/uploads/2014/06/ScreenShot20140605at12.45.54PM.gif&quot;&gt;&lt;img style=&quot;border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px&quot; title=&quot;Screen Shot 2014-06-05 at 12.45.54 PM&quot; border=&quot;0&quot; alt=&quot;Screen Shot 2014-06-05 at 12.45.54 PM&quot; src=&quot;/assets/ScreenShot20140605at12.45.54PM_thumb.gif&quot; width=&quot;407&quot; height=&quot;185&quot; /&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;这样就达到静态ip效果了。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;这样做的缺点是每个虚拟机都得建一个hostonly network。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;参见：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://superuser.com/questions/357120/how-do-i-setup-a-virtualbox-server-with-a-static-ip&quot; href=&quot;http://superuser.com/questions/357120/how-do-i-setup-a-virtualbox-server-with-a-static-ip&quot;&gt;http://superuser.com/questions/357120/how-do-i-setup-a-virtualbox-server-with-a-static-ip&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/linux/2014/06/05/virtualbox-e4-b8-8b-e8-ae-be-e7-bd-ae-e9-9d-99-e6-80-81ip.html</link>
                <guid>/linux/2014/06/05/virtualbox-%e4%b8%8b%e8%ae%be%e7%bd%ae%e9%9d%99%e6%80%81ip</guid>
                <pubDate>Thu, 05 Jun 2014 20:35:27 +0800</pubDate>
        </item>

        <item>
                <title>html checkbox半选状态问题</title>
                <description>&lt;p&gt;html5开始，checkbox开始支持indeterminate 属性，当它为true时，checkbox为半选状态，它不是一个html 标签属性，而是一个DOM对象属性。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;但是IE8是不支持的，IE9却又一贯性的与众不同，当点击半选时，IE9表现是为不选了，而其他浏览器都是全选，这里是在线测试 &lt;a title=&quot;http://jsfiddle.net/5tpXc/&quot; href=&quot;http://jsfiddle.net/5tpXc/&quot;&gt;http://jsfiddle.net/5tpXc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;还好有人解决了这个问题：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://stackoverflow.com/questions/10099158/how-to-deal-with-browser-differences-with-indeterminate-checkbox&quot; href=&quot;http://stackoverflow.com/questions/10099158/how-to-deal-with-browser-differences-with-indeterminate-checkbox&quot;&gt;http://stackoverflow.com/questions/10099158/how-to-deal-with-browser-differences-with-indeterminate-checkbox&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;在线演示 &lt;a title=&quot;http://jsfiddle.net/K6nrT/6/&quot; href=&quot;http://jsfiddle.net/K6nrT/6/&quot;&gt;http://jsfiddle.net/K6nrT/6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;参见：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://stackoverflow.com/questions/6269342/partially-select-checkbox-with-javascript&quot; href=&quot;http://stackoverflow.com/questions/6269342/partially-select-checkbox-with-javascript&quot;&gt;http://stackoverflow.com/questions/6269342/partially-select-checkbox-with-javascript&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/html5/web%E5%89%8D%E7%AB%AF/2014/05/30/html-checkbox-e5-8d-8a-e9-80-89-e7-8a-b6-e6-80-81-e9-97-ae-e9-a2-98.html</link>
                <guid>/html5/web%E5%89%8D%E7%AB%AF/2014/05/30/html-checkbox%e5%8d%8a%e9%80%89%e7%8a%b6%e6%80%81%e9%97%ae%e9%a2%98</guid>
                <pubDate>Fri, 30 May 2014 02:07:29 +0800</pubDate>
        </item>

        <item>
                <title>推荐较好的共享主机http://www.kvcwebhost.com/</title>
                <description>&lt;p&gt;受不了hostigation，128M的根本不能跑wordpress，想升级，客服吊儿郎当，只说需要多少钱没说怎么缴费，晕，估计他们就几个人兼顾运维和客服，不过他们的服务器确实不错。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;换了这个 &lt;a href=&quot;http://www.kvcwebhost.com/&quot; title=&quot;http://www.kvcwebhost.com/&quot;&gt;http://www.kvcwebhost.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;总结一个字非常棒&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;客服回应速度非常快，上下行速度都很不错，居然提供ssh控制，比较惊喜！&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;三年68刀，非常划算了。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;好的服务我就推荐一下了。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;中间我还试了一个ovh.com 法国人做事就是厉害，钱交了，扯了一个星期还没把我的主机弄好，最后我问他们进度他们要我验证身份，让人哭笑不得，罢了罢了！不过钱还是退回来了。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;=======================&lt;/p&gt;
&lt;p&gt;后记：现在kvhost也是速度很慢ping 都是400以上，总之是个渣。哎，兲朝的网速真是无语！&lt;/p&gt;
</description>
                <link>/web/2014/05/07/e6-8e-a8-e8-8d-90-e8-be-83-e5-a5-bd-e7-9a-84-e5-85-b1-e4-ba-ab-e4-b8-bb-e6-9c-bahttpwww-kvcwebhost-com.html</link>
                <guid>/web/2014/05/07/%e6%8e%a8%e8%8d%90%e8%be%83%e5%a5%bd%e7%9a%84%e5%85%b1%e4%ba%ab%e4%b8%bb%e6%9c%bahttpwww-kvcwebhost-com</guid>
                <pubDate>Wed, 07 May 2014 01:27:49 +0800</pubDate>
        </item>

        <item>
                <title>懒汉汉堡肉做法</title>
                <description>&lt;p&gt;这种做法用料简单，不会出现你不认识的调料，不做汉堡肉做饺子馅也是可以的。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;超市买来的猪肉馅，&lt;/p&gt;
&lt;p&gt;生姜切碎末，生姜不要太少，&lt;/p&gt;
&lt;p&gt;鸡蛋一个打入猪肉馅中&lt;/p&gt;
&lt;p&gt;切大葱或洋葱末&lt;/p&gt;
&lt;p&gt;切大白菜末&lt;/p&gt;
&lt;p&gt;以上都放入肉馅中朝一个方向搅&lt;/p&gt;
&lt;p&gt;当鸡蛋绞碎后，放入胡椒粉，面粉少许，生抽少许，盐少许，再搅&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;然后放置10分钟&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;将上面的肉馅依据自己喜好拿出一部分放在手上左右倒手，让里面的空气出来，做成小饼状，放在盘子里&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;重复上一步，做出许多肉饼&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;平底锅中小火放油，煎肉饼，盖锅盖，自己感觉要翻面了就翻一下，尽量让饼子压扁，这样容易熟&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;完成&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;加鸡蛋真的是个好主意，这样就不会散了，但是如果做饺子馅，就不需要加面粉了。&lt;/p&gt;
</description>
                <link>/%E7%94%9F%E6%B4%BB/2014/04/04/e6-87-92-e6-b1-89-e6-b1-89-e5-a0-a1-e8-82-89-e5-81-9a-e6-b3-95.html</link>
                <guid>/%E7%94%9F%E6%B4%BB/2014/04/04/%e6%87%92%e6%b1%89%e6%b1%89%e5%a0%a1%e8%82%89%e5%81%9a%e6%b3%95</guid>
                <pubDate>Fri, 04 Apr 2014 01:23:56 +0800</pubDate>
        </item>

        <item>
                <title>jackson json-lib配合完成xml json互换</title>
                <description>&lt;p&gt;前段时间优化性能，将原来用的json-lib转换为了jackson，现在要解析xml，发现jaconson解析xml有问题，它对数组元素直解析最后一个，真不知是出于什么考虑？&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;而json-lib则没有这个问题，但是json-lib输出的json格式有些多余的双引号转义，不是很标准，它生成的json是无法让jackson解析的。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;尝试了xstream，要自己写代码解析，不能用。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;最后只好两个结合起来用：&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;div style=&quot;padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px&quot; id=&quot;scid:812469c5-0cb0-4c63-8c15-c81123a09de7:95e3f4be-ffee-4d15-aec2-dda1c3b05351&quot; class=&quot;wlWriterEditableSmartContent&quot;&gt;
&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;  public static Map&amp;lt;String,Object&amp;gt; parseXml(String xml){
        try
        {
            xml = xml.replaceAll(&quot;&amp;gt;\s+&amp;lt;&quot;, &quot;&amp;gt;&amp;lt;&quot;);
            JSON json1 = (new XMLSerializer()).read(xml);
            String resoult = null;
            Map&amp;lt;String,Object&amp;gt; map = null;
            if(json1.isArray())
            {
                JSONArray jsonarray = (JSONArray)json1;
                map = (Map&amp;lt;String,Object&amp;gt;)jsonarray.get(0);
            }else{
                map = (Map&amp;lt;String,Object&amp;gt;)json1;
            } 

            return map;
        }
        catch (Exception e)
        {
            throw ExceptionUtils.silence(e);
        }
    }
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;转换为map后就好说了，再用jackson来转换为string&lt;/p&gt;
&lt;div style=&quot;padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px&quot; id=&quot;scid:812469c5-0cb0-4c63-8c15-c81123a09de7:d5ddfec2-16de-4640-8b42-77833859897c&quot; class=&quot;wlWriterEditableSmartContent&quot;&gt;
&lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;public static String toJsonString(Object obj) {
		if (null == obj) {
			return &quot;null&quot;;
		}
		StringWriter writer = new StringWriter();
		ObjectMapper mapper = new ObjectMapper();
		try {
			mapper.writeValue(writer, obj);
		} catch (Exception e) {
			throw ExceptionUtils.silence(e);
		}

		return writer.toString();
	}&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;maven依赖：&lt;/p&gt;
&lt;div style=&quot;padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px&quot; id=&quot;scid:812469c5-0cb0-4c63-8c15-c81123a09de7:cc8dadf3-39c6-4daf-ac60-d33f83597e0b&quot; class=&quot;wlWriterEditableSmartContent&quot;&gt;
&lt;pre name=&quot;code&quot; class=&quot;xml&quot;&gt;&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;jackson-core&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.2.3&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;net.sf.json-lib&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;json-lib&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
			&amp;lt;classifier&amp;gt;jdk15&amp;lt;/classifier&amp;gt;
		&amp;lt;/dependency&amp;gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
                <link>/java/2014/04/04/jackson-json-lib-e9-85-8d-e5-90-88-e5-ae-8c-e6-88-90xml-json-e4-ba-92-e6-8d-a2.html</link>
                <guid>/java/2014/04/04/jackson-json-lib%e9%85%8d%e5%90%88%e5%ae%8c%e6%88%90xml-json%e4%ba%92%e6%8d%a2</guid>
                <pubDate>Fri, 04 Apr 2014 01:07:58 +0800</pubDate>
        </item>

        <item>
                <title>hostigation.com vps主机使用吐槽</title>
                <description>&lt;p&gt;原来的vps（justhost）主机到期了，续费价格翻了4倍几乎300刀两年，这不宰人么，弃之。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;听说hostigation.com不错，且我测试ping值是比较快的，200ms平均，就买下了，30刀一年128M内存，想想一个小博客应该够了。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;而今：&lt;/p&gt;
&lt;p&gt;ping值奇怪的平均400ms，内存不是很够，mysql使用的最小内存配置，还是不行，经常无反应，现在博客响应速度很慢呢。还真不如我当初使用的某个二道贩子的20软妹币一年的，真上当了。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;折腾一番后，把apache一些模块禁止掉了，一下在节约了60M内存，再一测，速度还行。但是运行个查询就又没内存了。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;ping值按时间段不是很稳定，上次测得很慢，这次测又回到了200ms。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;参见：&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;基于wordpress优化apache性能：&lt;/p&gt;
&lt;p&gt;https://thethemefoundry.com/blog/optimize-apache-wordpress/&lt;/p&gt;
</description>
                <link>/web/2014/04/02/hostigation-com-vps-e4-b8-bb-e6-9c-ba-e4-bd-bf-e7-94-a8-e5-90-90-e6-a7-bd-2.html</link>
                <guid>/web/2014/04/02/hostigation-com-vps%e4%b8%bb%e6%9c%ba%e4%bd%bf%e7%94%a8%e5%90%90%e6%a7%bd-2</guid>
                <pubDate>Wed, 02 Apr 2014 23:04:54 +0800</pubDate>
        </item>

        <item>
                <title>onenote mac 免费版使用</title>
                <description>&lt;p&gt;onenote mac版推出了，马上使用一下，结果发现功能很多被阉割。但是还是不错的。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;我还是决定弃用：&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;1：不能粘贴网页格式，网页上粘贴的内容拷贝进去格式全没了。&lt;/p&gt;
&lt;p&gt;2：不能插入图片，点击插入图片，只见一个红叉叉，这有什么用？&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;还是用google drive。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;google drive mac版居然能下载下来，居然速度还可以。但是文件同步什么的还是不喜欢，直接网页版上写吧。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;=======================================&lt;/p&gt;
&lt;p&gt;今天通知onenote更新了，居然添加了上面的两个功能，难道微软在倾听用户的声音？&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;纠结要不要把google上的都转过来！！&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;=============================&lt;/p&gt;
&lt;p&gt;发现onenote急需要改进的地方：表格功能太弱，不能合并单元格等等……&lt;/p&gt;
</description>
                <link>/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/2014/04/02/onenote-mac-e5-85-8d-e8-b4-b9-e7-89-88-e4-bd-bf-e7-94-a8.html</link>
                <guid>/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/2014/04/02/onenote-mac-%e5%85%8d%e8%b4%b9%e7%89%88%e4%bd%bf%e7%94%a8</guid>
                <pubDate>Wed, 02 Apr 2014 22:38:21 +0800</pubDate>
        </item>

        <item>
                <title>【转】Java对象占用内存大小的分析与计算</title>
                <description>&lt;p&gt;&lt;font color=&quot;#0000ff&quot;&gt;转自 jloser.com/java对象占用内存大小的分析与计算/‎ （不知为什么google 报攻击站点）&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;new Object()将占用多少bytes的内存空间？可能大部分时候我们并不是很关心，但是经常有Java开发人员抱怨我们的应用程序越来越慢、越来越消耗内存，特别是在我们面临有限内存和应用功能不断增加的情况下；另一方面，我们在设计应用程序时又常常为对象创建是采用prototype还是singleton方式而犹豫不决。此时，我们有必要搞清楚，运行我们的应用程序究竟需要多少内存预算，而最消耗内存的又是哪些地方和哪些对象。通常，我们遇到这样的问题首先会想到使用Profiler工具来剖析下我们的应用程序，如JProfiler、VisualVM之类，这类工具能够胜任这项工作，但它们具有一定的学习门槛、操作过于复杂、无法与应用集成、本身也很耗内存。如果我们有个像c中的sizeof函数就好了，很不幸，Java没有，好在JDK1.5中发布了一个Instrumentation组件，我们可以借此来自定义一个sizeof工具来测量对象占用的内存大小。首先，在测试之前让我们理论分析下不同Java对象对内存的占用。 &lt;/p&gt;
&lt;p&gt;一. 须知事项: &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. 我们所说的Java对象占用内存大小仅是指分配在heap上的对象，在某些情况下JVM可能会在stack上或register上直接为对象分配存储区域，此外静态变量(static)是分配在method area上的； &lt;/p&gt;
&lt;p&gt;2. Java对象占用的内存大小在同一JVM内不同时间可能会发生变化, 这主要是内存占用还跟对象的状态有关，如当前对象内置锁的状态、是否正在等待GC回收等； &lt;/p&gt;
&lt;p&gt;3. 不同JVM里同样数据结构的对象占用的内存大小也有可能不一样大，这主要是内存占用还跟JVM实现、操作系统等有关。 &lt;/p&gt;
&lt;p&gt;二. 计算方法: &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. 通常我们想到的是借助Runtime#freeMemory(), 伪代码如下： &lt;/p&gt;
&lt;p&gt;long before = Runtime.getRuntime().freeMemory(); &lt;/p&gt;
&lt;p&gt;Object obj = new Object(); &lt;/p&gt;
&lt;p&gt;long after = Runtime.getRuntime().freeMemory(); &lt;/p&gt;
&lt;p&gt;System.out.println(&amp;quot;Object size: [&amp;quot; + (after - before) + &amp;quot;]&amp;quot;); &lt;/p&gt;
&lt;p&gt;2. 使用序列化技术将对象序列化成byte数组，再检查数组的长度。 &lt;/p&gt;
&lt;p&gt;3. 使用Reflection API遍历对象所有的fields然后累加。 &lt;/p&gt;
&lt;p&gt;4. 借助Instrumentation#getObjectSize(Object objectToSize) 计算。 &lt;/p&gt;
&lt;p&gt;方法1受GC的影响，准确度较低，有时会得出负值；方法2是错误的，序列化的结果是种特定格式的数据，这种格式在多JVM间兼容，但是这种格式的数据在内存中占用的空间大小与序列化后的结果无关；方法3设计复杂，且需要了解JVM实现；方法4简单明了，官方API，可靠，也是本文底层采用的方法。 &lt;/p&gt;
&lt;p&gt;三. 计算范围: &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. Shallow, 仅计算为本对象本身新分配的内存大小。 &lt;/p&gt;
&lt;p&gt;2. Deep, 计算本对象本身及引用对象、引用对象的引用…所有关联对象占用的内存大小。 &lt;/p&gt;
&lt;p&gt;四. 原生类型(primitive type)的内存占用 &lt;/p&gt;
&lt;p&gt;Primitive Type&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Memory Required(bytes) &lt;/p&gt;
&lt;p&gt;————————————————————— &lt;/p&gt;
&lt;p&gt;boolean&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 1 &lt;/p&gt;
&lt;p&gt;byte&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 1 &lt;/p&gt;
&lt;p&gt;short&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 2 &lt;/p&gt;
&lt;p&gt;char&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 2 &lt;/p&gt;
&lt;p&gt;int&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 4 &lt;/p&gt;
&lt;p&gt;float&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 4 &lt;/p&gt;
&lt;p&gt;long&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 8 &lt;/p&gt;
&lt;p&gt;double&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 8 &lt;/p&gt;
&lt;p&gt;————————————————————— &lt;/p&gt;
&lt;p&gt;五. 对象类型(reference type)的内存占用 &lt;/p&gt;
&lt;p&gt;下文中的32位（64位）系统是指32位（64位）的JVM。 &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. 一个object header, 也称object overhead, 保存当前实例的type信息和内置monitor信息等, 32位系统上占用8bytes，64位系统上占用16bytes； &lt;/p&gt;
&lt;p&gt;2. 0到多个fields, reference类型在32位系统上每个占用4bytes, 在64位系统上每个占用8bytes; primitive类型参考上面； &lt;/p&gt;
&lt;p&gt;3. padding, 对步骤1、2之和的补长。CPU从内存中读取数据是以word为基本单位, 32位的系统中word宽度为32bits, 64位的系统中word宽度为64bits, 将整个Java对象占用内存补长为word的整倍数大大提高了CPU存取数据的性能，参考维基百科关于数据alignment的说明 。 就Hotspot而言，不管是32位系统还是64位系统要求（步骤1 + 步骤2 + padding） % 8等于0且0 &amp;lt;= padding &amp;lt; 8。例如在64位系统上: &lt;/p&gt;
&lt;p&gt;public class Student { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; private int age; &lt;/p&gt;
&lt;p&gt;} &lt;/p&gt;
&lt;p&gt;如new Student()则其占用内存: 16 + 4 = 20，按照3中的说明则padding为4bytes，这样整个内存占用为24bytes。 &lt;/p&gt;
&lt;p&gt;六. 一维原生数组的内存占用 &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. 在32位的系统中, 占用内存为: 型别占用内存 * 数组长度 + 8（数组在JVM中被当成特殊的对象, object overhead占用8bytes） + 4（数组长度） + padding。如： &lt;/p&gt;
&lt;p&gt;byte[2], 型别占用内存，即byte型别占用1byte，数组长度为2，这样占用的总内存为1 * 2 + 8 + 4 = 14，padding上2bytes为16bytes，所以byte[2]占用内存为16bytes。 &lt;/p&gt;
&lt;p&gt;2. 在64位的系统中, 占用内存为: 型别占用内存 * 数组长度 + 16（object overhead占用16bytes） + 8（数组长度） + padding。如： &lt;/p&gt;
&lt;p&gt;byte[2], 型别占用内存，即byte型别占用1byte，数组长度为2，这样占用的总内存为1 * 2 + 16 + 8 = 26，padding上6bytes，26 + 6 = 32bytes，所以byte[2]占用内存为32bytes &lt;/p&gt;
&lt;p&gt;七. 多维数组和一维对象数组 &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. 在32位的系统中, 占用内存为: reference占用内存 * 数组第1维长度 +12(数组本身被当做reference占8bytes，数组长度占4bytes)。如： &lt;/p&gt;
&lt;p&gt;byte[3][7], reference占用内存4byte，数组第1维长度为3，这样占用的总内存为4 * 3 + 12 = 24，所以byte[3][7]占用内存为24bytes。再如byte[7][3], reference占用内存4byte，数组第1维长度为7，这样占用的总内存为4 * 7 + 12 = 40，所以byte[7][3]占用内存为40bytes。再如new HashMap[7][6][4]，reference占用内存4byte，数组第1维长度为7，这样占用的总内存为4 * 7 + 12 = 40，所以HashMap[7][6][4]占用内存为40bytes。 &lt;/p&gt;
&lt;p&gt;2. 在64位的系统中, 占用内存为: reference占用内存 * 数组第1维长度 +24(数组本身被当做reference占16bytes，数组长度占8bytes)。如： &lt;/p&gt;
&lt;p&gt;byte[3][7], reference占用内存8byte，数组第1维长度为3，这样占用的总内存为8 * 3 + 24 = 48，所以byte[3][7]占用内存为48bytes。 &lt;/p&gt;
&lt;p&gt;八. 编码计算 &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. java.lang.instrument.Instrumentation实例由JVM产生，我们需实现一个代理(agent)，根据java.lang.instrument的package specification说明，这个代理里需有个public static void premain(String agentArgs, Instrumentation inst); 方法，这样在JVM初始化后在调用应用程序main方法前，JVM将调用我们agent里的这个premain方法，这样就注入了Instrumentation实例。 &lt;/p&gt;
&lt;p&gt;2. 计算实例的内存大小，通过Instrumentation#getObjectSize(Object objectToSize)获得。 &lt;/p&gt;
&lt;p&gt;3. 注意: 如果有field是常量（如, Boolean.FALSE），因为多实例共享，所以算其占用内存为0。 &lt;/p&gt;
&lt;p&gt;4. 如计算对象Deep范围内存占用的话则需递归计算引用对象占用的内存，然后进行累加。 &lt;/p&gt;
&lt;p&gt;5. 代码实现如下MemoryCalculator.java： &lt;/p&gt;
&lt;p&gt;/* &lt;/p&gt;
&lt;p&gt; * @(#)MemoryCalculator.java&amp;#160;&amp;#160;&amp;#160; 1.0 2010-11-8 &lt;/p&gt;
&lt;p&gt; * &lt;/p&gt;
&lt;p&gt; * Copyright 2010 Richard Chen(utopia_rabbi@sse.buaa.edu.cn) All Rights Reserved. &lt;/p&gt;
&lt;p&gt; * PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. &lt;/p&gt;
&lt;p&gt; */ &lt;/p&gt;
&lt;p&gt;package charpter.memory; &lt;/p&gt;
&lt;p&gt;import java.lang.instrument.Instrumentation; &lt;/p&gt;
&lt;p&gt;import java.lang.reflect.Array; &lt;/p&gt;
&lt;p&gt;import java.lang.reflect.Field; &lt;/p&gt;
&lt;p&gt;import java.lang.reflect.Modifier; &lt;/p&gt;
&lt;p&gt;import java.util.IdentityHashMap; &lt;/p&gt;
&lt;p&gt;import java.util.Map; &lt;/p&gt;
&lt;p&gt;import java.util.Stack; &lt;/p&gt;
&lt;p&gt;/** &lt;/p&gt;
&lt;p&gt; * 提供实例占用内存大小的计算功能. 内部借助JVM的{@link Instrumentation}实现. &lt;/p&gt;
&lt;p&gt; * &lt;/p&gt;
&lt;p&gt; * @author Rich, 2010-11-8. &lt;/p&gt;
&lt;p&gt; * @version 1.0 &lt;/p&gt;
&lt;p&gt; * @since 1.0 &lt;/p&gt;
&lt;p&gt; */ &lt;/p&gt;
&lt;p&gt;public final class MemoryCalculator { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; /** &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * JVM在初始化后在调用应用程序main方法前将调用本方法, 本方法中可以写任何main方法中可写的代码. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param agentArgs 命令行传进行来的代理参数, 内部需自行解析. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param inst JVM注入的句柄. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; */ &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; public static void premain(String agentArgs, Instrumentation inst) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; instrumentation = inst; &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; /** &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * 计算实例本身占用的内存大小. 注意: &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * 1. 多次调用可能结果不一样, 主要跟实例的状态有关 &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * 2. 实例中成员变量如果是reference类型, 则reference所指向的实例占用内存大小不统计在内 &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param obj 待计算内存占用大小的实例. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @return 内存占用大小, 单位为byte. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; */ &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; public static long shallowSizeOf(Object obj) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; if (instrumentation == null) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; throw new IllegalStateException(&amp;quot;Instrumentation initialize failed&amp;quot;); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; if (isSharedObj(obj)) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return 0; &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return instrumentation.getObjectSize(obj); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; /** &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * 计算实例占用的内存大小, 含其成员变量所引用的实例, 递归计算. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param obj 待计算内存占用大小的实例. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @return 内存占用大小, 单位为byte. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; */ &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; public static long deepSizeOf(Object obj) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Map calculated = new IdentityHashMap(); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Stack unCalculated = new Stack(); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; unCalculated.push(obj); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; long result = 0; &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; do { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result += doSizeOf(unCalculated, calculated); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } while (!unCalculated.isEmpty()); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return result; &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; /** &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * 判断obj是否是共享对象. 有些对象, 如interned Strings, Boolean.FALSE和Integer#valueOf()等. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param obj 待判断的对象. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @return true, 是共享对象, 否则返回false. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; */ &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; private static boolean isSharedObj(Object obj) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; if (obj instanceof Comparable) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; if (obj instanceof Enum) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return true; &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } else if (obj instanceof String) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return (obj == ((String) obj).intern()); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } else if (obj instanceof Boolean) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return (obj == Boolean.TRUE || obj == Boolean.FALSE); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } else if (obj instanceof Integer) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return (obj == Integer.valueOf((Integer) obj)); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } else if (obj instanceof Short) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return (obj == Short.valueOf((Short) obj)); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } else if (obj instanceof Byte) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return (obj == Byte.valueOf((Byte) obj)); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } else if (obj instanceof Long) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return (obj == Long.valueOf((Long) obj)); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } else if (obj instanceof Character) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return (obj == Character.valueOf((Character) obj)); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return false; &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; /** &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * 确认是否需计算obj的内存占用, 部分情况下无需计算. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param obj 待判断的对象. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param calculated 已计算过的对象. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @return true, 意指无需计算, 否则返回false. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; */ &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; private static boolean isEscaped(Object obj, Map calculated) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return obj == null || calculated.containsKey(obj) &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; || isSharedObj(obj); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; /** &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * 计算栈顶对象本身的内存占用. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param unCalculated 待计算内存占用的对象栈. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param calculated 对象图谱中已计算过的对象. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @return 栈顶对象本身的内存占用, 单位为byte. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; */ &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; private static long doSizeOf(Stack unCalculated, Map calculated) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Object obj = unCalculated.pop(); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; if (isEscaped(obj, calculated)) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return 0; &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Class clazz = obj.getClass(); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; if (clazz.isArray()) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; doArraySizeOf(clazz, obj, unCalculated); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } else { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; while (clazz != null) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Field[] fields = clazz.getDeclaredFields(); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; for (Field field : fields) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; if (!Modifier.isStatic(field.getModifiers()) &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; &amp;amp;&amp;amp; !field.getType().isPrimitive()) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; field.setAccessible(true); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; try { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; unCalculated.add(field.get(obj)); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } catch (IllegalAccessException ex) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; throw new RuntimeException(ex); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; clazz = clazz.getSuperclass(); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; calculated.put(obj, null); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; return shallowSizeOf(obj); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; /** &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * 将数组中的所有元素加入到待计算内存占用的栈中, 等待处理. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param arrayClazz 数组的型别. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param array 数组实例. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; * @param unCalculated 待计算内存占用的对象栈. &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160; */ &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; private static void doArraySizeOf(Class arrayClazz, Object array, &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Stack unCalculated) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; if (!arrayClazz.getComponentType().isPrimitive()) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; int length = Array.getLength(array); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; for (int i = 0; i &amp;lt; length; i++) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; unCalculated.add(Array.get(array, i)); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; /** JVM将在启动时通过{@link #premain}初始化此成员变量. */ &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; private static Instrumentation instrumentation = null; &lt;/p&gt;
&lt;p&gt;} &lt;/p&gt;
&lt;p&gt;以上代码请参考: &lt;a href=&quot;http://www.javaspecialists.eu/archive/Issue142.html。&quot;&gt;http://www.javaspecialists.eu/archive/Issue142.html。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;九. 打包及测试 &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. 将MemoryCalculator.java编译后打包为javatutorial.jar，修改jar中的META-INF/MANIFEST.MF文件，在文件结尾处添加新的一行Premain-Class: charpter.memory.MemoryCalculator，注意冒号后有一个空格，行尾有回车。 &lt;/p&gt;
&lt;p&gt;2. 编写测试代码TestMem.java，如下: &lt;/p&gt;
&lt;p&gt;/* &lt;/p&gt;
&lt;p&gt; * @(#)TestMem.java&amp;#160;&amp;#160;&amp;#160; 1.0 2010-11-8 &lt;/p&gt;
&lt;p&gt; * &lt;/p&gt;
&lt;p&gt; * Copyright 2010 Richard Chen(email: utopia_rabbi@sse.buaa.edu.cn) All Rights Reserved. &lt;/p&gt;
&lt;p&gt; * PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. &lt;/p&gt;
&lt;p&gt; */ &lt;/p&gt;
&lt;p&gt;package charpter.mem; &lt;/p&gt;
&lt;p&gt;import java.util.HashMap; &lt;/p&gt;
&lt;p&gt;import charpter.memory.MemoryCalculator; &lt;/p&gt;
&lt;p&gt;/** &lt;/p&gt;
&lt;p&gt; * Java对象内存占用的测试. &lt;/p&gt;
&lt;p&gt; * &lt;/p&gt;
&lt;p&gt; * @author Rich, 2010-11-8. &lt;/p&gt;
&lt;p&gt; * @version 1.0 &lt;/p&gt;
&lt;p&gt; * @since 1.0 &lt;/p&gt;
&lt;p&gt; */ &lt;/p&gt;
&lt;p&gt;public class TestMem { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; public static void main(String[] args) { &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; long result = MemoryCalculator.shallowSizeOf(new Object()); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new byte[1000]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new byte[2]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new byte[2][3]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new byte[3][3]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new byte[9][3]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new byte[2][3][3]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new byte[7][3]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new byte[3][7]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new byte[7][6][4]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new HashMap[7][6][4]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; result = MemoryCalculator.shallowSizeOf(new HashMap[7]); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(result); &lt;/p&gt;
&lt;p&gt;&amp;#160;&amp;#160;&amp;#160; } &lt;/p&gt;
&lt;p&gt;} &lt;/p&gt;
&lt;p&gt;3. 编译TestMem.java，然后执行之。注意在命令行要指定代理类，即: -javaagent:javatutorial.jar，以下为本人在自己测试环境下的执行结果 &lt;/p&gt;
&lt;p&gt;a. Linux, 64bits, 64位JDK1.5, 执行命令: java -javaagent:/home/adapp/javatutorial.jar -cp /home/adapp/javatutorial.jar:/home/adapp/ charpter.mem.TestMem &lt;/p&gt;
&lt;p&gt;结果输出： &lt;/p&gt;
&lt;p&gt;16 &lt;/p&gt;
&lt;p&gt;1024 &lt;/p&gt;
&lt;p&gt;32 &lt;/p&gt;
&lt;p&gt;40 &lt;/p&gt;
&lt;p&gt;48 &lt;/p&gt;
&lt;p&gt;96 &lt;/p&gt;
&lt;p&gt;40 &lt;/p&gt;
&lt;p&gt;80 &lt;/p&gt;
&lt;p&gt;48 &lt;/p&gt;
&lt;p&gt;80 &lt;/p&gt;
&lt;p&gt;80 &lt;/p&gt;
&lt;p&gt;80 &lt;/p&gt;
&lt;p&gt;b. Windows 7, 32bits, 32位JDK1.5, 配置的命令行参数为: -javaagent:D:/Temp/javatutorial.jar，执行结果 &lt;/p&gt;
&lt;p&gt;8 &lt;/p&gt;
&lt;p&gt;1016 &lt;/p&gt;
&lt;p&gt;16 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;48 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;40 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;40 &lt;/p&gt;
&lt;p&gt;40 &lt;/p&gt;
&lt;p&gt;40 &lt;/p&gt;
&lt;p&gt;c. Windows 7, 64bits, 32位JDK1.5, 配置的命令行参数为: -javaagent:D:/Temp/javatutorial.jar，执行结果 &lt;/p&gt;
&lt;p&gt;8 &lt;/p&gt;
&lt;p&gt;1016 &lt;/p&gt;
&lt;p&gt;16 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;48 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;40 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;40 &lt;/p&gt;
&lt;p&gt;40 &lt;/p&gt;
&lt;p&gt;40 &lt;/p&gt;
&lt;p&gt;d. Windows 7, 64bits, 64位JDK1.7.0_09, 配置的命令行参数为: -javaagent:D:/Temp/javatutorial.jar，执行结果 &lt;/p&gt;
&lt;p&gt;16 &lt;/p&gt;
&lt;p&gt;1016 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;32 &lt;/p&gt;
&lt;p&gt;56 &lt;/p&gt;
&lt;p&gt;24 &lt;/p&gt;
&lt;p&gt;48 &lt;/p&gt;
&lt;p&gt;32 &lt;/p&gt;
&lt;p&gt;48 &lt;/p&gt;
&lt;p&gt;48 &lt;/p&gt;
&lt;p&gt;48 &lt;/p&gt;
&lt;p&gt;从上述输出结果可以看出，案例a, b, c与步骤四至七的理论分析一致。案例d与理论分析不完全一致，但是大小比例关系依然存在，这主要是Hotspot对对象指针采用了压缩算法，由官方资料关于Compressed oops（ordinary object pointer）的说明 可以看出，从Java SE 6u23之后的64位版本就默认打开了对象指针压缩。 &lt;/p&gt;
&lt;p&gt;十. Compressed oops的内存占用 &lt;/p&gt;
&lt;p&gt;注意，Compressed oops只在64位的JVM中才会有，另外，在Java SE 6u23之前的1.6版本中需要通过-XX:+UseCompressedOops参数开启。压缩算法对对象内存占用计算的影响主要在于: &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. object header，未压缩前由一个native-sized mark word 8bytes加上一个class word 8bytes组成，共16bytes。采用压缩后，class word缩减为8bytes，现共占用12bytes； &lt;/p&gt;
&lt;p&gt;2. reference类型，由8bytes缩减为4bytes； &lt;/p&gt;
&lt;p&gt;3. 数组长度，由8bytes缩减为4bytes。 &lt;/p&gt;
&lt;p&gt;所以，上述测试案例中: &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. 原生类型，内存占用大小不变。 &lt;/p&gt;
&lt;p&gt;2. 对象类型，object header由16bytes变更为12bytes，reference类型的fields由8bytes变更为4bytes，primitive类型的fields保持不变，padding不变。 &lt;/p&gt;
&lt;p&gt;3. 一维原生数组，如new byte[2]占用内存的计算公式由：型别占用内存 * 数组长度 + 16 + 8 + padding变更为: 型别占用内存 * 数组长度 + 12 + 4 + padding，这样得到: 1byte * 2 + 12 + 4 = 18，padding上6bytes等于24bytes。 &lt;/p&gt;
&lt;p&gt;4. 多维数组和一维对象数组，如new byte[3][7]，计算公式由: reference占用内存 * 数组第1维长度 +24(数组本身被当做reference占16bytes，数组长度占8bytes) 变更为: reference占用内存 * 数组第1维长度 + 16(object header 12bytes，数组长度占4bytes) + padding，这样得到：4bytes * 3 + 16 = 28，padding上4bytes等于32bytes。 再如new HashMap[7]，7 * 4bytes + 16 = 44bytes，padding上4bytes为48bytes。 &lt;/p&gt;
&lt;p&gt;十一. 总结 &lt;/p&gt;
&lt;p&gt;通过上述Java内存占用大小的理论分析与实际测试，给我们实际开发带来几点重要的启发: &lt;/p&gt;
&lt;p&gt;——————————————————————————————– &lt;/p&gt;
&lt;p&gt;1. 同样的程序在不同环境下运行，占用的内存不一样大小，64位系统上占用的内存要比在32位系统上多1至1.5倍； &lt;/p&gt;
&lt;p&gt;2. n个元素的数组要比n个单独元素占用更大的内存，特别是primitive类型的数组； &lt;/p&gt;
&lt;p&gt;3. 定义多维数组时，要尽可能把长度小的放在第1维，即int[9][1]要比int[1][9]占用更多内存，Integer[1000][4][3]远比Integer[3][4][1000]占用的内存要多得多； &lt;/p&gt;
&lt;p&gt;4. Java SE 6u23之后的64位版本要比之前的版本在对象内存占用方面小得多。 &lt;/p&gt;
&lt;p&gt;十二. 参考资源 &lt;/p&gt;
&lt;p&gt;1. &lt;a href=&quot;http://www.javamex.com/tutorials/memory/object_memory_usage.shtml&quot;&gt;http://www.javamex.com/tutorials/memory/object_memory_usage.shtml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://wikis.oracle.com/display/HotSpotInternals/CompressedOops&quot; href=&quot;https://wikis.oracle.com/display/HotSpotInternals/CompressedOops&quot;&gt;2. https://wikis.oracle.com/display/HotSpotInternals/CompressedOops&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/java/2014/04/02/e3-80-90-e8-bd-ac-e3-80-91java-e5-af-b9-e8-b1-a1-e5-8d-a0-e7-94-a8-e5-86-85-e5-ad-98-e5-a4-a7-e5-b0-8f-e7-9a-84-e5-88-86-e6-9e-90-e4-b8-8e-e8-ae-a1-e7-ae-97.html</link>
                <guid>/java/2014/04/02/%e3%80%90%e8%bd%ac%e3%80%91java%e5%af%b9%e8%b1%a1%e5%8d%a0%e7%94%a8%e5%86%85%e5%ad%98%e5%a4%a7%e5%b0%8f%e7%9a%84%e5%88%86%e6%9e%90%e4%b8%8e%e8%ae%a1%e7%ae%97</guid>
                <pubDate>Wed, 02 Apr 2014 22:23:03 +0800</pubDate>
        </item>

        <item>
                <title>maven 拷贝所有依赖到指定目录</title>
                <description>&lt;div style=&quot;padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px&quot; id=&quot;scid:812469c5-0cb0-4c63-8c15-c81123a09de7:8d0d8b1a-871b-4b05-a9c5-7c48a8a1b8cb&quot; class=&quot;wlWriterEditableSmartContent&quot;&gt;
&lt;pre name=&quot;code&quot; class=&quot;xml&quot;&gt;&amp;lt;plugin&amp;gt;
           &amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt;
           &amp;lt;executions&amp;gt;
             &amp;lt;execution&amp;gt;
               &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
               &amp;lt;goals&amp;gt;
                 &amp;lt;goal&amp;gt;copy-dependencies&amp;lt;/goal&amp;gt;
               &amp;lt;/goals&amp;gt;
               &amp;lt;configuration&amp;gt;
                 &amp;lt;outputDirectory&amp;gt;${project.build.directory}/lib&amp;lt;/outputDirectory&amp;gt;
               &amp;lt;/configuration&amp;gt;
             &amp;lt;/execution&amp;gt;
           &amp;lt;/executions&amp;gt;
         &amp;lt;/plugin&amp;gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;其中 ${project.build.directory}是指当前工程的target目录，运行package则会将所有依赖包拷贝到lib目录下。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;参见：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://stackoverflow.com/questions/97640/force-maven2-to-copy-dependencies-into-target-lib&quot; href=&quot;http://stackoverflow.com/questions/97640/force-maven2-to-copy-dependencies-into-target-lib&quot;&gt;http://stackoverflow.com/questions/97640/force-maven2-to-copy-dependencies-into-target-lib&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/java/2014/03/31/maven-e6-8b-b7-e8-b4-9d-e6-89-80-e6-9c-89-e4-be-9d-e8-b5-96-e5-88-b0-e6-8c-87-e5-ae-9a-e7-9b-ae-e5-bd-95.html</link>
                <guid>/java/2014/03/31/maven-%e6%8b%b7%e8%b4%9d%e6%89%80%e6%9c%89%e4%be%9d%e8%b5%96%e5%88%b0%e6%8c%87%e5%ae%9a%e7%9b%ae%e5%bd%95</guid>
                <pubDate>Mon, 31 Mar 2014 19:11:54 +0800</pubDate>
        </item>

        <item>
                <title>同源跨窗口添加脚本的上下文</title>
                <description>&lt;p&gt;这次遇到个问题，子窗体脚本向父窗体添加了个脚本，但是添加的脚本的上下文却是子窗体！也就是说，在被添加的脚本中操作dom其实是操作的子窗体的dom，window对象也是子窗体的window。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;为什么这样我还没找到文档。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;类似这样：&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;子窗体脚本：&lt;/p&gt;
&lt;p&gt;$(‘head’,parent.document).append(‘&amp;lt;script src=”xxxx.js”&amp;gt;&amp;lt;/script&amp;gt;’);&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;xxx.js里:&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;log(window);&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;会发现是子窗体的window对象。&lt;/p&gt;
</description>
                <link>/web%E5%89%8D%E7%AB%AF/2014/02/18/e5-90-8c-e6-ba-90-e8-b7-a8-e7-aa-97-e5-8f-a3-e6-b7-bb-e5-8a-a0-e8-84-9a-e6-9c-ac-e7-9a-84-e4-b8-8a-e4-b8-8b-e6-96-87.html</link>
                <guid>/web%E5%89%8D%E7%AB%AF/2014/02/18/%e5%90%8c%e6%ba%90%e8%b7%a8%e7%aa%97%e5%8f%a3%e6%b7%bb%e5%8a%a0%e8%84%9a%e6%9c%ac%e7%9a%84%e4%b8%8a%e4%b8%8b%e6%96%87</guid>
                <pubDate>Tue, 18 Feb 2014 18:22:42 +0800</pubDate>
        </item>

        <item>
                <title>Evernote 使用后感</title>
                <description>&lt;p&gt;今天试用了一下Evernote， 界面做的不错，国内也没被墙，很想将被兲朝虐的不行Google Drive里的资料导进去，发现居然不可以。PDF，word什么的都不支持。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;网上所抱怨的格式兼容什么的确实不假，想想还是算了，难道还一篇篇重写不成，我还那么多图片在文档里。果断删了。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;还是凑合着用Google吧，虽然那动不动就“正在联系服务器”的提示让人咬牙切齿，但还是很强大的。&lt;/p&gt;
</description>
                <link>/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/2014/01/27/evernote-e4-bd-bf-e7-94-a8-e5-90-8e-e6-84-9f.html</link>
                <guid>/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/2014/01/27/evernote-%e4%bd%bf%e7%94%a8%e5%90%8e%e6%84%9f</guid>
                <pubDate>Mon, 27 Jan 2014 04:43:24 +0800</pubDate>
        </item>

        <item>
                <title>mac osx 拷贝当前文件夹路径</title>
                <description>&lt;p&gt;mac osx下要活的当前文件夹路径不是个很方便的事情，因为它没有winows那样的地址栏，那么：&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;p&gt;command+I获得简介，从里面copy路径&amp;#160; 这个不好用&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;网上找到的&lt;/p&gt;
&lt;p&gt;在launchpad里打开Automator，在实用工具里找到Run AppleScript，选择no input，从左边Run AppleScript拖到右边，就会出现脚本编辑。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;拷贝脚本&lt;/p&gt;
&lt;p&gt;try   &lt;br /&gt;&amp;#160;&amp;#160;&amp;#160; tell application &amp;quot;Finder&amp;quot; to set the clipboard to POSIX path of (target of window 1 as alias)    &lt;br /&gt;on error    &lt;br /&gt;&amp;#160;&amp;#160;&amp;#160; beep    &lt;br /&gt;end try&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;替换(* Your script goes here *)&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;command+save 保存一个名字。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;然后你就可以在系统设置、键盘快捷键、通用下 找到你创建的服务，给它一个快捷键，那么在任何文件夹下只要这个快捷键就可以将其拷贝到粘贴板上了。&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;&amp;#160;&lt;/p&gt;
&lt;p&gt;具体参见：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://apple.stackexchange.com/questions/47216/copying-the-current-directorys-path-to-the-clipboard&quot; href=&quot;http://apple.stackexchange.com/questions/47216/copying-the-current-directorys-path-to-the-clipboard&quot;&gt;http://apple.stackexchange.com/questions/47216/copying-the-current-directorys-path-to-the-clipboard&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/apple/2014/01/09/mac-osx-e6-8b-b7-e8-b4-9d-e5-bd-93-e5-89-8d-e6-96-87-e4-bb-b6-e5-a4-b9-e8-b7-af-e5-be-84.html</link>
                <guid>/apple/2014/01/09/mac-osx-%e6%8b%b7%e8%b4%9d%e5%bd%93%e5%89%8d%e6%96%87%e4%bb%b6%e5%a4%b9%e8%b7%af%e5%be%84</guid>
                <pubDate>Thu, 09 Jan 2014 19:42:15 +0800</pubDate>
        </item>

        <item>
                <title>eclipse 遇到很多验证错误</title>
                <description>&lt;p&gt;往往导入一个新工程，发现很多语法验证错误，但那本不是错误。看的很烦心，这个问题我以前碰到过，只是没有烂一下笔头，这次又出现了，弄了半天，才发现在problems里点击这些错误，右键删除即可。&lt;/p&gt;
</description>
                <link>/java/2014/01/09/eclipse-e9-81-87-e5-88-b0-e5-be-88-e5-a4-9a-e9-aa-8c-e8-af-81-e9-94-99-e8-af-af.html</link>
                <guid>/java/2014/01/09/eclipse-%e9%81%87%e5%88%b0%e5%be%88%e5%a4%9a%e9%aa%8c%e8%af%81%e9%94%99%e8%af%af</guid>
                <pubDate>Thu, 09 Jan 2014 00:42:06 +0800</pubDate>
        </item>


</channel>
</rss>
