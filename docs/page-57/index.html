<!DOCTYPE html>
<html lang="en"><!--
 __  __                __                                     __
/\ \/\ \              /\ \             __                    /\ \
\ \ \_\ \   __  __    \_\ \      __   /\_\      __       ___ \ \ \/'\
 \ \  _  \ /\ \/\ \   /'_` \   /'__`\ \/\ \   /'__`\    /'___\\ \ , <
  \ \ \ \ \\ \ \_\ \ /\ \L\ \ /\  __/  \ \ \ /\ \L\.\_ /\ \__/ \ \ \\`\
   \ \_\ \_\\/`____ \\ \___,_\\ \____\ _\ \ \\ \__/.\_\\ \____\ \ \_\ \_\
    \/_/\/_/ `/___/> \\/__,_ / \/____//\ \_\ \\/__/\/_/ \/____/  \/_/\/_/
                /\___/                \ \____/
                \/__/                  \/___/

Powered by Hydejack v6.6.1 <https://qwtel.com/hydejack/>
--><head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="format-detection" content="telephone=no"> <meta http-equiv="x-ua-compatible" content="ie=edge"> <title>Ka's Blog &middot; Ka's Blog</title> <meta name="description" content="Ka’s blog description… "> <link rel="canonical" href="http://localhost:4000/page-57/"> <link rel="alternate" type="application/atom+xml" title="Ka's Blog Feed" href="http://localhost:4000/feed.xml"> <link rel="apple-touch-icon" href="/apple-touch-icon.png"> <!-- Place favicon.ico in the root directory --> <link rel="stylesheet" href="/assets/style.css"> <link id="_katexJS" rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.js"> <link id="_katexCSS" rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.css"> <!--[if gt IE 8]><!----> <script> WebFontConfig = { google: { families: 'Roboto+Slab:700|Noto+Sans:400,400i,700,700i'.split('|') }, custom: { families: ['icomoon'], urls: ['/assets/icomoon/style.css'] } }; </script> <!--<![endif]--> <script> !function(n,e){function t(n,e){n.onload=function(){this.onerror=this.onload=null,e(null,n)},n.onerror=function(){this.onerror=this.onload=null,e(new Error("Failed to load "+this.src),n)}}function o(n,e){n.onreadystatechange=function(){"complete"!=this.readyState&&"loaded"!=this.readyState||(this.onreadystatechange=null,e(null,n))}}n._loaded=!1,n.loadJSDeferred=function(a,d){function r(){n._loaded=!0;var r=e.createElement("script");r.src=a,d&&(("onload"in r?t:o)(r,d),r.onload||t(r,d));var l=e.getElementsByTagName("script")[0];l.parentNode.insertBefore(r,l)}n._loaded?r():n.addEventListener?n.addEventListener("load",r,!1):n.attachEvent?n.attachEvent("onload",r):n.onload=r}}(window,document); !function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this); !function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this); window.disablePushState = false; window.disableDrawer = false; </script> <!--[if lt IE 9]> <script src="/assets/bower_components/html5shiv/dist/html5shiv.min.js"></script> <![endif]--> <!--[if gt IE 8]><!----> <style> article, aside, dialog, figcaption, figure, footer, header, hgroup, main, nav, section { display: block; } mark { background: #FF0; color: #000; } * { box-sizing: border-box; } html, body { margin: 0; padding: 0; } html { font-size: 16px; line-height: 1.75; } body { color: #333; background-color: #fff; overflow-y: scroll; } a { text-decoration: none; } .lead { margin-left: -1rem; margin-right: -1rem; } img, .img { display: block; max-width: 100%; margin-bottom: 1rem; border: none; } img.lead, .img.lead { max-width: calc(100% + 2rem); width: calc(100% + 2rem); } h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6, .heading { font-weight: bold; text-rendering: optimizeLegibility; } h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 { margin: 3rem 0 1rem; line-height: 1.6; } h1, .h1 { font-size: 2rem; line-height: 1.25; } h2, .h2 { font-size: 1.5rem; } h3, .h3 { font-size: 1.17em; } p { margin-top: 0; margin-bottom: 1rem; } p.lead { font-size: 1.25rem; font-weight: 300; padding: 0 1rem; } ul, ol, dl { margin-top: 0; margin-bottom: 1rem; } ul, ol { padding-left: 1.25rem; } hr { position: relative; margin: 1.5rem 0; border: 0; border-top: 1px solid #eee; } .hr { padding-bottom: .5rem; border-bottom: 1px solid #eee; margin-bottom: 1.5rem; } h4, h5, h6, .h4, .h5, .h6 { margin-bottom: 0.5rem; font-size: 1rem; } table { margin-bottom: 1rem; width: 100%; width: calc(100% + 2rem); margin-left: -1rem; border: 1px solid #e5e5e5; border-collapse: collapse; border-spacing: 0; } td, th { padding: .25rem .5rem; border: 1px solid #e5e5e5; } td:first-child, th:first-child { padding-left: 1rem; } td:last-child, th:last-child { padding-right: 1rem; } thead + tbody, tbody + tbody, tfoot { border-top: 3px double #e5e5e5; } tbody tr:nth-child(odd) td, tbody tr:nth-child(odd) th { background-color: #f9f9f9; } footer { margin-bottom: 2rem; } .page, .post { margin-bottom: 3em; } .page li + li, .post li + li { margin-top: .25rem; } .page > header, .post > header { margin-bottom: 2rem; } .page-title, .post-title { margin-top: 0; } .post-date { display: block; margin-top: -0.5rem; margin-bottom: 1rem; color: #9a9a9a; } .related-posts { padding-left: 0; list-style: none; } .related-posts > li, .related-posts > li + li { margin-top: 1rem; } .related-posts > li > small, .related-posts > li + li > small { font-size: 75%; color: #9a9a9a; } .message { margin-bottom: 1rem; padding: 1rem; color: #787878; background-color: #f9f9f9; margin-left: -1rem; margin-right: -1rem; } /* * Global resets * * Update the foundational and global aspects of the page. */ body, main { /* Prevent side-scrolling on mobile */ position: relative; overflow-x: hidden; } @media screen { body::before { content: ''; width: .5rem; background: #e5e5e5; position: absolute; left: 0; top: 0; bottom: 0; } } @media screen and (min-width: 40em) { html { font-size: 17px; } } @media screen and (min-width: 54em) { html { font-size: 16px; } } @media screen and (min-width: 72em) { html { font-size: 17px; } } @media screen and (min-width: 125em) { html { font-size: 18px; } } .sr-only { display: none; } .clearfix, .sidebar-social::after, .clearafter::after { content: ""; display: table; clear: both; } a, .a { position: relative; padding-bottom: .15rem; border-bottom: 1px solid; } .img { overflow: hidden; background-color: #f9f9f9; } .img > img { margin: 0; width: 100%; height: 100%; } .sixteen-nine { position: relative; } .sixteen-nine::before { display: block; content: ""; width: 100%; padding-top: 56.25%; } .sixteen-nine > * { position: absolute; top: 0; left: 0; right: 0; bottom: 0; } h1 + hr, h2 + hr, h3 + hr, h4 + hr, h5 + hr, h6 + hr { margin-top: 0; } .fade-in { animation-duration: 500ms; animation-name: fade-in; animation-fill-mode: forwards; } @keyframes fade-in { from { transform: translateY(-2rem); opacity: 0; } 50% { transform: translateY(-2rem); opacity: 0; } to { transform: translateY(0); opacity: 1; } } .mb6 { margin-bottom: 6rem; } .sidebar { color: rgba(255, 255, 255, 0.75); text-align: left; /* Sidebar links */ } .sidebar::before { /* make sidebar slightly darker to increase text readability (when using a background image) */ content: ""; position: absolute; z-index: 2; top: 0; left: 0; bottom: 0; right: 0; background: linear-gradient(to bottom, rgba(32, 32, 32, 0) 0%, rgba(32, 32, 32, 0.5) 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */ } .sidebar a { color: #fff; border-bottom-color: rgba(255, 255, 255, 0.2); } #_yDrawer { position: relative; padding: 1rem 0; } @media screen { #_yDrawer { padding: 2rem 1rem; min-height: 640px; min-height: 100vh; } } @media screen and (min-width: 54em) { #_yDrawer { position: fixed; top: 0; left: 0; bottom: 0; width: 18rem; margin-left: 0; } } @media screen and (min-width: 97.5em) { #_yDrawer { width: calc(50% - 28rem); } } @media screen { #_yDrawer.loaded { min-height: 0; padding: 0; } } .sidebar-bg { position: absolute; top: 0; right: 0; bottom: 0; left: 0; background: #202020 center / cover; } .sidebar-sticky { position: relative; z-index: 3; } @media screen { .sidebar-sticky { position: absolute; right: 2rem; bottom: 1rem; left: auto; max-width: 14rem; } } @media print { .sidebar-sticky { padding: 0 2rem; } } /* About section */ .sidebar-about > h1 { color: #fff; font-size: 2rem; } .sidebar-nav > ul { list-style: none; padding-left: 0; margin-bottom: .5rem; } a.sidebar-nav-item { font-weight: bold; display: block; line-height: 1.75; padding: .25rem 0; border-bottom: 1px solid rgba(255, 255, 255, 0.2); } @media screen { .y-drawer-scrim { z-index: 2; } .y-drawer-content { width: 18rem; left: -17.5rem; z-index: 3; } } @media screen and (min-width: 97.5em) { .y-drawer-content { width: calc(50% - 28rem); } } .sidebar-social { margin-bottom: .5rem; } .sidebar-social > ul { list-style: none; padding-left: 0; margin: 0 -.25rem; } .sidebar-social > ul > li { float: left; margin: 0 .25rem; } .sidebar-social > ul > li > a { display: inline-block; text-align: center; font-size: 1.6rem; line-height: 3rem; width: 3.1249rem; height: 4rem; padding: .5rem 0; } .sidebar-social > ul li + li { margin-top: 0; } .fixed-top { position: fixed; top: 0; left: 0; width: 100%; z-index: 1; } .navbar > .content { padding-top: 0; padding-bottom: 0; min-height: 0; height: 0; } .menu { display: inline-block; padding: 1.75rem 1.5rem; border-bottom: none; margin-left: -1.5rem; color: #9a9a9a !important; } .menu::after { content: "\2630"; } @media screen and (min-width: 54em) { .menu { padding: 1.25rem 1.5rem; position: absolute; left: -9999px; } .menu:focus { position: static; } } .animation-main { pointer-events: none; } .loading { display: none; } @media print { .menu { display: none; } } .animation-main { opacity: 0; will-change: opacity; } .loading { position: absolute; top: 0; right: 0; padding: 5.25rem 4.5rem; transform-origin: top right; transform: scale(0.33); } .content { position: relative; margin-left: auto; margin-right: auto; padding: 5rem 1rem 12rem; } @media screen { .content { max-width: 38rem; padding-left: 1.5rem; min-height: 100vh; } } @media screen and (min-width: 54em) { .content { max-width: 42rem; padding: 4rem 1rem 12rem; margin-left: 22rem; margin-right: 4rem; } } @media screen and (min-width: 72em) { .content { margin-left: 22rem; margin-right: 4rem; } } @media screen and (min-width: 92em) { .content { max-width: 48rem; } } @media screen and (min-width: 97.5em) { .content { margin: auto; } } .me { float: right; width: 6.5rem; height: 6.5rem; margin-left: 1rem; margin-bottom: .5rem; border-radius: 100%; position: relative; } @media screen and (min-width: 40em) { .me { width: 7rem; height: 7rem; } } @media screen and (min-width: 54em) { .me { width: 6.5rem; height: 6.5rem; } } @media screen and (min-width: 60em) { .me { width: 7rem; height: 7rem; } } main > footer { position: absolute; bottom: 0; left: 0; right: 0; padding: 0 1rem; color: #9a9a9a; font-size: smaller; text-align: center; } main > footer > p { margin-bottom: 0; } /* .card, .pagination-item { border-radius: 0!important; } */ /* @media screen { .sidebar-sticky { left: 2rem; max-width: none; } } */ html { font-family: Helvetica, Arial, sans-serif; } h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6, .heading { font-family: Helvetica, Arial, sans-serif; } </style> <link id="_stylePreload" rel="preload" as="style" href="/assets/css/hydejack.css?v=6.6.1"> <script>document.getElementById('_stylePreload').onload=function(){this.rel='stylesheet'}</script> <!-- NOTE: These styles interact with JavsScript, so they MUST NOT be changed --> <style id="_pageStyle"> .content a { color: #4f86aa; border-color: rgba(79, 134, 170, 0.2); } .content a:hover { border-color: #4f86aa; } :focus { outline-color: #4f86aa; } ::selection { color: #fff; background: #4f86aa; } ::-moz-selection { color: #fff; background: #4f86aa; } </style> <noscript> <link rel="stylesheet" href="/assets/css/hydejack.css?v=6.6.1"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:700|Noto+Sans:400,400i,700,700i"> <style> html { font-family: 'Noto Sans', Helvetica, Arial, sans-serif } h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6, .heading { font-family: 'Roboto Slab', Helvetica, Arial, sans-serif } </style> <link rel="stylesheet" href="/assets/icomoon/style.css"> </noscript> <!--<![endif]--> <!--[if gt IE 8]><!----> <script async src="/assets/bower_components/webfontloader/webfontloader.js"></script> <!--<![endif]--> </head> <body> <div class="navbar fixed-top"> <div class="content"> <span class="sr-only">Jump to:</span> <a id="_menu" class="menu no-hover" href="#_title"> <span class="sr-only">Menu</span> </a> </div> </div> <div id="_yPushState"> <div class="fade-in"> <main id="_main" class="content" role="main" data-color="#4f86aa" data-image=""> <article id="post-java/web/2011/05/30/%e6%88%91%e5%87%ba%e7%9a%84webjava%e9%9d%a2%e8%af%95%e9%a2%98" class="post mb6" role="article"> <header> <h1 class="post-title"> <a href="/java/web/2011/05/30/e6-88-91-e5-87-ba-e7-9a-84webjava-e9-9d-a2-e8-af-95-e9-a2-98.html" data-flip="title"> 我出的web,java面试题 </a> </h1> <p class="post-date heading"> <time datetime="2011-05-30T16:08:31+08:00">30 May 2011</time> in <span>Java</span> / <span>Web</span> on <span>面试</span> </p> <div class="hr" style="padding-bottom:0"></div> </header> <p>自我介绍 <br />技术题 <br />web容器用过哪些，优缺点 <br />margin 方向顺序 <br />经验 <br />1:你最喜欢的编程语言是什么，为什么喜欢它，如果你喜欢的是java的话，你觉得它与javascript有什么区别吗？如果不是，你觉得你喜欢的语言与java又有什么区别？能谈谈你对javascript的看法吗？&#160;&#160;&#160; <br />2:能谈谈过去18个月中java平台发生了什么事情吗？ <br />2009</p> <p>Oracle收购Sun</p> <p>除了Oracle和Sun的故事，SpringSource的一系列举动在Groovy社区表现得也很活跃：收购Groovy和Grails技术的 幕后公司G2One，收购系统管理软件厂商Hyperic，随后SpringSource又被VMWare收购，在虚拟市场取得立足点。</p> <p>另外，Terracotta收购了Quartz和ehCache开源框架。</p> <p>Java开发领域2011年度热点回顾与展望 <a href="http://tech.it168.com/a2011/1216/1289/000001289885_1.shtml">http://tech.it168.com/a2011/1216/1289/000001289885_1.shtml</a></p> <p>&#160;</p> <p>3:如果你想学一种新的编程语言，你对那个比较感兴趣，为什么？ <br />4:你非常喜欢的web应用有哪些，为什么喜欢他们？ <br />5:你喜欢UI开发吗?你自己是否写过web UI组件，如果是，请介绍一下这些组件并谈谈你的体会。 <br />6:你觉得开发web应用最糟糕的事情和最好的情况分别是什么，你觉得使用web应用最糟糕的事情和最好的情况又分别是什么？ <br />7:能谈谈你对html5的看法吗？ <br />8:如果你有一年的时间做些事情，你打算做什么，为什么要这样做？ <br />9:你能谈谈你最有话要说的你参与过的项目吗？ <br />10:你参与过开源项目吗？如果有，请介绍一下这个项目并谈谈你的体会？ <br />你认为你有什么优缺点？</p> <p class="read-more">Continue reading <a class="heading" href="/java/web/2011/05/30/e6-88-91-e5-87-ba-e7-9a-84webjava-e9-9d-a2-e8-af-95-e9-a2-98.html" data-flip="title">我出的web,java面试题</a></p> </article> <article id="post-php/2011/05/30/discuz7%e5%ae%89%e8%a3%85" class="post mb6" role="article"> <header> <h1 class="post-title"> <a href="/php/2011/05/30/discuz7-e5-ae-89-e8-a3-85.html" data-flip="title"> discuz7安装 </a> </h1> <p class="post-date heading"> <time datetime="2011-05-30T16:07:40+08:00">30 May 2011</time> in <span>Php</span> on <span>Discuzz</span>, <span>Php</span>, <span>Web</span> </p> <div class="hr" style="padding-bottom:0"></div> </header> <p><a href="">上传后使用http://localhost:10080/diz7/install/index.php安装</a> <br />依据提示来 <br />php默认配置mysql.dll,mysql pdo mysqli三个扩展都没启用，且extension_dir = &quot;ext&quot;也注释了，都要启用 <br />安装数据库时我使用localhost不行，127.0.0.1倒是可以</p> <p class="read-more">Continue reading <a class="heading" href="/php/2011/05/30/discuz7-e5-ae-89-e8-a3-85.html" data-flip="title">discuz7安装</a></p> </article> <article id="post-java/2011/05/30/swing-%e5%bc%80%e5%8f%91-assist-%e5%8a%9f%e8%83%bd%e9%97%ae%e9%a2%98" class="post mb6" role="article"> <header> <h1 class="post-title"> <a href="/java/2011/05/30/swing-e5-bc-80-e5-8f-91-assist-e5-8a-9f-e8-83-bd-e9-97-ae-e9-a2-98.html" data-flip="title"> swing 开发 assist 功能问题 </a> </h1> <p class="post-date heading"> <time datetime="2011-05-30T16:06:16+08:00">30 May 2011</time> in <span>Java</span> on <span>Swing</span>, <span>Ui</span> </p> <div class="hr" style="padding-bottom:0"></div> </header> <p>swing 开发 assist 功能问题： <br />关键点获得输入光标的位置。 <br />Point p = textArea.getCaret().getMagicCaretPosition(); <br />mask 一定要在dot之前 <br />setdot后再movedot这时应该是向后，看jdk源码就知道了。 <br />swing 点击window的title栏时，不会触发window的click事件，即使使用Toolkit.getDefaultToolkit().addAWTEventListener的方式也不行 <br />requestFocusInWindow如果不起作用，那要检查顶级窗体是否获得焦点，topWin.setVisible(true);即可 <br />event.consume方法是可以取消事件的，但是对于textarea来说，要禁止输入最好在 <br />keypress-&gt;keytyped-&gt;keyrealease三个里面都consume,不然还是会输入字符。 <br />swing的事件不是像html dom那样冒泡，它会从最底层控件的事件监听器找起，没有才会向上冒泡。而且getSource是没什么用的(往往是添加监听器本身的控件)。</p> <p class="read-more">Continue reading <a class="heading" href="/java/2011/05/30/swing-e5-bc-80-e5-8f-91-assist-e5-8a-9f-e8-83-bd-e9-97-ae-e9-a2-98.html" data-flip="title">swing 开发 assist 功能问题</a></p> </article> <article id="post-web%E5%89%8D%E7%AB%AF/2011/05/30/%e3%80%90%e8%bd%ac%e3%80%91javascript%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f" class="post mb6" role="article"> <header> <h1 class="post-title"> <a href="/web%E5%89%8D%E7%AB%AF/2011/05/30/e3-80-90-e8-bd-ac-e3-80-91javascript-e5-8f-98-e9-87-8f-e4-bd-9c-e7-94-a8-e5-9f-9f.html" data-flip="title"> 【转】JavaScript变量作用域 </a> </h1> <p class="post-date heading"> <time datetime="2011-05-30T16:05:48+08:00">30 May 2011</time> in <span>Web前端</span> </p> <div class="hr" style="padding-bottom:0"></div> </header> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: bold; text-decoration: none" id="internal-source-marker_0.279392012200097">一、JavaScript变量作用域(scope)</span> <br /><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">首先需要明白的几个要点：</span> <br /><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">1.JavaScript的变量作用域是基于其特有的作用域链的。</span> <br /><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">2.JavaScript没有块级作用域。</span> <br /><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">3.函数中声明的变量在整个函数中都有定义。（就后面第三点的说明）</span> <br /><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">4 .所有在最外层定义（非函数体内定义）的变量都拥有全局作用域</span> <br /><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">5. 所有末定义直接赋值的变量，系统会自动声明为拥有全局作用域的变量</span> <br /><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">6. 所有window对象的属性拥有全局作用域</span> <br /><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">（下面作者还提到全局变量都可以通过window.*来访问，明白这一点很重要，但是否准确？此外目前存在的疑问还有：</span> <br /><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160;&#160; 即使可以以这中方式来访问全局变量那是否能认为全局对象由window来统一管理，还是window只是保存了一个拷贝而已?）</span> </p> <p>这是正确的，例：</p> <div><pre>&lt;script type=&quot;<span style="color: #8b0000">text/javascript</span>&quot;&gt;
    	<span style="color: #0000ff">var</span> s = '1';
    	
    	<span style="color: #0000ff">alert</span>(<span style="color: #0000ff">window</span>.s);
    &lt;/script&gt;</pre></div> <p>结果是1</p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160;&#160; </span></p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #0000ff; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">1.JavaScript的作用域链</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">首先看一个很简单的例子，下面的代码中，定义一个全局变量n，n的作用域是全局的。 </span></p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var n=1;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show(){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; var m=2;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; alert(n);&#160; //显示结果为1</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show();</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">运行代码后，结果为1。</span><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: bold; text-decoration: none">原理就是JavaScript作用域是层层包含的，外层的作用域在内层有效，执行的时候，从内层向外层查找。</span><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">当函数show执行的时候，首先在函数show内部查找变量n，没有找到，再向外层查找，找到了全局变量n，alert显示结果为1。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none"></span></p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #0000ff; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">2.局部变量优先级高于全局变量</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var n=1;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show(){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; var m=2;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; var n=3;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; alert(n);&#160; //显示结果为3</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show();</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">这个不难理解，根据上面变量作用域链的原理，函数执行时，会先从内层向外层查找，如果在内层中找到变量，查找就会停止。所以内层的作用域会优先于外层，局部优先于全局。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">稍改一下：</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var n=1;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show(){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; var m=2;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; var n=3;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; alert(window.n);&#160; //显示结果为1</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show();</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">为什么会是1，而不是3呢，只是另外一个问题：</span><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: bold; text-decoration: none">全局变量都是window对象的属性</span><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: bold; text-decoration: none">，任何的全局变量都是window对象的属性，都可以用window.*来引用</span><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">。(*代表一个变量)</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none"></span></p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #0000ff; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">3.在函数内部使用var声明的变量，不论在何处声明，该变量都拥有整个函数的作用域。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var n=1;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show(){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; alert(n);&#160; //undefined</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; alert(this.n); //显示为1</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; var n=3;&#160; //声明局部变量n</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; alert(n);&#160; //显示为3</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show();</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">第一个问什么会显示undefined呢，这个问题的原因就是在函数后面声明了局部变量n=3，在函数show执行的时候，会先从内层查找变量n，结果找到了，但在第一个alert的时候，n还没有赋值，故结果为undefined。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #0000ff; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none"></span></p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #0000ff; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">4.JavaScript没有块级作用域</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var n=1;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show(){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">for(var i=0;i&lt;3;i++){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160; var n=6;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160; alert(i);&#160; //显示结果为0,1,2</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">alert(&quot;for循环外：&quot;+i); //显示结果为：“for循环外：3”</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">alert(&quot;n=&quot;+n);&#160; //显示结果为：n=6</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">//alert(i);&#160; 外部引用一个未声明变量会提示出错</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show();</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">变量i虽然是在for循环内定义的，但for循环块外部仍然可以引用，i的作用域是整个函数show。如果在show函数外部引用i变量，会出现JavaScript报错。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #0000ff; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none"></span></p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #0000ff; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">5.没有使用var声明的变量属于全局变量</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var n=1;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show(){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; m=9;&#160; //声明变量m</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; var s=6;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show();&#160; //不可少，alert之前需要先执行m=9，否则m未声明</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">alert(m);&#160; //显示9</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">alert(window.m);&#160; //显示9</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">alert(s);&#160; //报错&quot;s is not defined&quot;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">函数show执行的过程中，引用了变量m，但未使用var声明，m就变成了全局变量。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: bold; text-decoration: none">二、JavaScript匿名函数</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">所谓匿名函数就是没有命名的函数，看起来有点难以理解，其实很常见，下面举一个小例子。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">window.onload=function(){ alert(&quot;加载完毕！&quot;);}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">这样就创建了一个匿名函数，这个function没有函数名，但可以被调用和执行，当网页加载完毕时，会执行alert()。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">(function(x,y){alert(x+y)})(2,3);&#160; //显示结果为5</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">上面的方法仍然是创建了一个匿名函数，并使用()优先表达式强制执行函数。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: bold; text-decoration: none">三、JavaScript闭包(closure)</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">闭包其实就是利用了函数作用域和匿名函数的知识，当函数A执行结束时，一部分变量变量被B引用，被引用的变量不能释放，形成了所谓的闭包。这里</span><a href="http://www.cnblogs.com/eoiioe/archive/2009/04/17/1438151.html"><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000099; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: underline">有篇很好的文章</span></a><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">，可以参考一下。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">下面看一个小例子：</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show(){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160; var n=3;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160; setTimeout(function(){alert(&quot;first:&quot;+n);},3000); //3秒后显示first:3</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160; alert(&quot;second:&quot;+n); //显示second:3</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show();</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show2(){alert(&quot;第一个函数执行结束&quot;);}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show2();</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">运行上面的函数后，首先alert显示&quot;second:3&quot;，然后显示&quot;第一个函数执行结束&quot;，3秒后显示“first:3”。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none"></span></p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">仔 细看一下，函数show执行结束的时候，变量n应该被释放了，内存里也就不存在了，怎么过了3秒还能显示出&quot;first:3&quot;呢？闭包恰恰就在此产生了， 当函数show执行结束的时候，想要释放内存里的n，但发现变量n还在被一个匿名函数引用，要在3秒后调用，根据JavaScript闭包原理，内存里的 n被保留了下来，于是在三秒以后仍然可以调用n。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">下面看几种写法的区别：</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show2(content){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">alert(content);&#160; //3秒后alert显示&quot;test&quot;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show(content,delay_time){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160; setTimeout(&quot;show2('&quot;+content+&quot;')&quot;,delay_time);</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show(&quot;test&quot;,3000);</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">仔细看一下上面这种写法不是闭包，只是普通的函数调用而已。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show(content,delay_time){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160; setTimeout(function(){alert(content)},delay_time); //3秒后alert显示&quot;test&quot;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show(&quot;test&quot;,3000);</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">这种写法就是闭包，虽然结果是一样的，但原理不一样。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">function show(content){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160; function show2(){alert(content);}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160; return show2;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var newshow=show(&quot;test&quot;);</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">setTimeout(newshow,3000);&#160; //3秒后alert显示&quot;test&quot;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">上面这种写法也是闭包，虽然结果都是一样的，但原理却不一样。这里面看到了函数也可以当作对象也传递，函数show执行后return show2，把函数show2赋值给newshow，然后3秒后，调用newshow对象，执行函数show2。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">仔细比较上面3种写法，如果能悟出一些道理就好，闭包有些时候的确难理解。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #008080; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">稍复杂一点的例子：</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var show=null;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">(function(){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var n=1;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var show2=function(){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160;&#160;&#160;&#160; alert(n++);</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show=show2;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">})();</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none"></span></p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show();&#160; //显示1</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show();&#160; //显示2</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">show();&#160; //显示3</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">上面代码中，又一次用了函数作为对象传递，n是匿名函数里的局部变量，外部是访问不到的。show是一个全局变量，应该访问不了变量n，但在函数 show执行前，首先把函数匿名函数内部show2赋值给show，当后面函数show运行的时候，会调用show2的代码，而show2是可以访问n 的，故结果显示为1、2、3。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #0000ff; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">另外一点值得注意的，也是很经典的一个例子。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">CSS代码：</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">ul{ width:600px; margin:0px auto;}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">ul li{ margin:1px 0px; background-color:#999999;}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">HTML代码：</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;ul&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;li&gt;1&lt;/li&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;li&gt;2&lt;/li&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;li&gt;3&lt;/li&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;li&gt;4&lt;/li&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/ul&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">JavaScript代码：</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var li=document.getElementsByTagName(&quot;li&quot;);</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">for(var i=0;i&lt;li.length;i++){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; li[i].onclick=function(){alert(i);}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">运行后，不论点击哪一个li，都是alert提示“4”。这就是一个需要注意的地方：</span><span style="background-color: transparent; font-style: normal; font-family: arial; color: #ff0000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">闭包允许内层函数引用父函数中的变量，但是该变量是最终值。</span><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">闭包引用的变量i，是循环结束后的值，其实这是一个很常见的问题，解决方法也有很多。</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">比较常见的就是给li[i]添加属性值，比如li[i].n=i；还有就是用闭包方法解决，这个函数本身就是闭包，所谓用闭包来解决闭包的问题。代码如下：</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">var li=document.getElementsByTagName(&quot;li&quot;);</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">for(var i=0;i&lt;li.length;i++){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; (function(index){</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; li[index].onclick=function(){alert(index);}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&#160; })(i);</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">}</span> </p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none">&lt;/script&gt;</span> </p> <p></p> <p><span style="background-color: transparent; font-style: normal; font-family: arial; color: #000000; font-size: 11pt; vertical-align: baseline; font-weight: normal; text-decoration: none"></span></p> <p class="read-more">Continue reading <a class="heading" href="/web%E5%89%8D%E7%AB%AF/2011/05/30/e3-80-90-e8-bd-ac-e3-80-91javascript-e5-8f-98-e9-87-8f-e4-bd-9c-e7-94-a8-e5-9f-9f.html" data-flip="title">【转】JavaScript变量作用域</a></p> </article> <article id="post-%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%ae%89%e5%85%a8%e6%8a%80%e6%9c%af%e6%a1%86%e6%9e%b6%e7%bb%bc%e8%bf%b0" class="post mb6" role="article"> <header> <h1 class="post-title"> <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/e6-95-b0-e6-8d-ae-e5-ba-93-e7-b3-bb-e7-bb-9f-e5-ae-89-e5-85-a8-e6-8a-80-e6-9c-af-e6-a1-86-e6-9e-b6-e7-bb-bc-e8-bf-b0.html" data-flip="title"> 数据库系统安全技术框架综述 </a> </h1> <p class="post-date heading"> <time datetime="2011-05-30T16:04:52+08:00">30 May 2011</time> in <span>数据库</span> on <span>数据库</span> </p> <div class="hr" style="padding-bottom:0"></div> </header> <p>1. 前言</p> <p> 随着计算机技术的飞速发展，数据库的应用十分广泛，深入到各个领域，但随之而来产生了数据的安全问题。各种应用系统的数据库中大量数据的安全问题、敏 感数据的防窃取和防篡改问题，越来越引起人们的高度重视。数据库系统作为信息的聚集体，是计算机信息系统的核心部件，其安全性至关重要，关系到企业兴衰、 国家安全。因此，如何有效地保证数据库系统的安全，实现数据的保密性、完整性和有效性，已经成为业界人士探索研究的重要课题之一，本文就安全防入侵技术做 简要的讨论。</p> <p> 数据库系统的安全除依赖自身内部的安全机制外，还与外部网络环境、应用环境、从业人员素质等因素息息相关，因此，从广义上讲，数据库系统的安全框架可以划分为三个层次：</p> <p> ⑴ 网络系统层次；</p> <p> ⑵ 宿主操作系统层次；</p> <p> ⑶ 数据库管理系统层次。</p> <p> 这三个层次构筑成数据库系统的安全体系，与数据安全的关系是逐步紧密的，防范的重要性也逐层加强，从外到内、由表及里保证数据的安全。下面就安全框架的三个层次展开论述。</p> <p>2. 网络系统层次安全技术</p> <p> 从广义上讲，数据库的安全首先倚赖于网络系统。随着Internet的发展普及，越来越多的公司将其核心业务向互联网转移，各种基于网络的数据库应用 系统如雨后春笋般涌现出来，面向网络用户提供各种信息服务。可以说网络系统是数据库应用的外部环境和基础，数据库系统要发挥其强大作用离不开网络系统的支 持，数据库系统的用户（如异地用户、分布式用户）也要通过网络才能访问数据库的数据。网络系统的安全是数据库安全的第一道屏障，外部入侵首先就是从入侵网 络系统开始的。网络入侵试图破坏信息系统的完整性、机密性或可信任的任何网络活动的集合，具有以下特点：</p> <p> a）没有地域和时间的限制，跨越国界的攻击就如同在现场一样方便；</p> <p> b）通过网络的攻击往往混杂在大量正常的网络活动之中，隐蔽性强；</p> <p> c）入侵手段更加隐蔽和复杂。</p> <p> 计算机网络系统开放式环境面临的威胁主要有以下几种类型：a)欺骗（Masquerade）；b)重发(Replay)；c)报文修改 (Modification of message)；d)拒绝服务(Deny of service)；e)陷阱门(Trapdoor)；f)特洛伊木马(Trojan horse)；g)攻击如透纳攻击（Tunneling Attack）、应用软件攻击等。这些安全威胁是无时、无处不在的，因此必须采取有效的措施来保障系统的安全。</p> <p> 从技术角度讲，网络系统层次的安全防范技术有很多种，大致可以分为防火墙、入侵检测、协作式入侵检测技术等。</p> <p> ⑴防火墙。防火墙是应用最广的一种防范技术。作为系统的第一道防线，其主要作用是监控可信任网络和不可信任网络之间的访问通道，可在内部与外部网络之 间形成一道防护屏障，拦截来自外部的非法访问并阻止内部信息的外泄，但它无法阻拦来自网络内部的非法操作。它根据事先设定的规则来确定是否拦截信息流的进 出，但无法动态识别或自适应地调整规则，因而其智能化程度很有限。防火墙技术主要有三种：数据包过滤器(packet filter)、代理(proxy)和状态分析(stateful inspection)。现代防火墙产品通常混合使用这几种技术。</p> <p> ⑵入侵检测。入侵检测(IDS-- Instrusion Detection System)是近年来发展起来的一种防范技术，综合采用了统计技术、规则方法、网络通信技术、人工智能、密码学、推理等技术和方法，其作用是监控网络和 计算机系统是否出现被入侵或滥用的征兆。1987年，Derothy Denning首次提出了一种检测入侵的思想，经过不断发展和完善，作为监控和识别攻击的标准解决方案，IDS系统已经成为安全防御系统的重要组成部分。</p> <p> 入侵检测采用的分析技术可分为三大类：签名、统计和数据完整性分析法。</p> <p> ①签名分析法。主要用来监测对系统的已知弱点进行攻击的行为。人们从攻击模式中归纳出它的签名，编写到IDS系统的代码里。签名分析实际上是一种模板匹配操作。</p> <p> ②统计分析法。以统计学为理论基础，以系统正常使用情况下观察到的动作模式为依据来判别某个动作是否偏离了正常轨道。</p> <p> ③数据完整性分析法。以密码学为理论基础，可以查证文件或者对象是否被别人修改过。</p> <p> IDS的种类包括基于网络和基于主机的入侵监测系统、基于特征的和基于非正常的入侵监测系统、实时和非实时的入侵监测系统等。</p> <p> ⑶协作式入侵监测技术</p> <p> 独立的入侵监测系统不能够对广泛发生的各种入侵活动都做出有效的监测和反应，为了弥补独立运作的不足，人们提出了协作式入侵监测系统的想法。在协作式 入侵监测系统中，IDS基于一种统一的规范，入侵监测组件之间自动地交换信息，并且通过信息的交换得到了对入侵的有效监测，可以应用于不同的网络环境。</p> <p>3. 宿主操作系统层次安全技术</p> <p> 操作系统是大型数据库系统的运行平台，为数据库系统提供一定程度的安全保护。目前操作系统平台大多数集中在Windows NT 和Unix，安全级别通常为C1、C2级。主要安全技术有操作系统安全策略、安全管理策略、数据安全等方面。</p> <p> 操作系统安全策略用于配置本地计算机的安全设置，包括密码策略、账户锁定策略、审核策略、IP安全策略、用户权利指派、加密数据的恢复代理以及其它安全选项[7]。具体可以体现在用户账户、口令、访问权限、审计等方面。</p> <p> 用户账户：用户访问系统的&quot;身份证&quot;，只有合法用户才有账户。</p> <p> 口令：用户的口令为用户访问系统提供一道验证。</p> <p> 访问权限：规定用户的权限。</p> <p> 审计：对用户的行为进行跟踪和记录，便于系统管理员分析系统的访问情况以及事后的追查使用。</p> <p> 安全管理策略是指网络管理员对系统实施安全管理所采取的方法及策略。针对不同的操作系统、网络环境需要采取的安全管理策略一般也不尽相同，其核心是保证服务器的安全和分配好各类用户的权限。</p> <p> 数据安全主要体现在以下几个方面：数据加密技术、数据备份、数据存储的安全性、数据传输的安全性等。可以采用的技术很多，主要有Kerberos认证、IPSec、SSL、TLS、VPN（PPTP、L2TP）等技术。</p> <p>4. 数据库管理系统层次安全技术</p> <p> 数据库系统的安全性很大程度上依赖于数据库管理系统。如果数据库管理系统安全机制非常强大，则数据库系统的安全性能就较好。目前市场上流行的是关系式数据库管理系统，其安全性功能很弱，这就导致数据库系统的安全性存在一定的威胁。</p> <p> 由于数据库系统在操作系统下都是以文件形式进行管理的，因此入侵者可以直接利用操作系统的漏洞窃取数据库文件，或者直接利用OS工具来非法伪造、篡改数据库文件内容。这种隐患一般数据库用户难以察觉，分析和堵塞这种漏洞被认为是B2级的安全技术措施。</p> <p> 数据库管理系统层次安全技术主要是用来解决这一问题，即当前面两个层次已经被突破的情况下仍能保障数据库数据的安全，这就要求数据库管理系统必须有一 套强有力的安全机制。解决这一问题的有效方法之一是数据库管理系统对数据库文件进行加密处理，使得即使数据不幸泄露或者丢失，也难以被人破译和阅读。</p> <p> 我们可以考虑在三个不同层次实现对数据库数据的加密，这三个层次分别是OS层、DBMS内核层和DBMS外层。</p> <p> ⑴在OS层加密。在OS层无法辨认数据库文件中的数据关系，从而无法产生合理的密钥，对密钥合理的管理和使用也很难。所以，对大型数据库来说，在OS层对数据库文件进行加密很难实现。</p> <p> ⑵在DBMS内核层实现加密。这种加密是指数据在物理存取之前完成加/脱密工作。这种加密方式的优点是加密功能强，并且加密功能几乎不会影响DBMS 的功能，可以实现加密功能与数据库管理系统之间的无缝耦合。其缺点是加密运算在服务器端进行，加重了服务器的负载，而且DBMS和加密器之间的接口需要 DBMS开发商的支持。</p> <p> 定义加密要求工具</p> <p> DBMS</p> <p> 数据库应用系统</p> <p> 加密器</p> <p> （软件或硬件）</p> <p> ⑶在DBMS外层实现加密。比较实际的做法是将数据库加密系统做成DBMS的一个外层工具，根据加密要求自动完成对数据库数据的加/脱密处理：</p> <p> 定义加密要求工具加密器</p> <p> （软件或硬件）</p> <p> DBMS</p> <p> 数据库应用系统</p> <p> 采用这种加密方式进行加密，加/脱密运算可在客户端进行，它的优点是不会加重数据库服务器的负载并且可以实现网上传输的加密，缺点是加密功能会受到一些限制，与数据库管理系统之间的耦合性稍差。</p> <p> 下面我们进一步解释在DBMS外层实现加密功能的原理：</p> <p> 数据库加密系统分成两个功能独立的主要部件：一个是加密字典管理程序，另一个是数据库加/脱密引擎。数据库加密系统将用户对数据库信息具体的加密要求 以及基础信息保存在加密字典中，通过调用数据加/脱密引擎实现对数据库表的加密、脱密及数据转换等功能。数据库信息的加/脱密处理是在后台完成的，对数据 库服务器是透明的。</p> <p> 加密字典管理程序</p> <p> 加密系统</p> <p> 应用程序</p> <p> 数据库加脱密引擎</p> <p> 数据库服务器</p> <p> 加密字典</p> <p> 用户数据</p> <p> 按以上方式实现的数据库加密系统具有很多优点：首先，系统对数据库的最终用户是完全透明的，管理员可以根据需要进行明文和密文的转换工作；其次，加密 系统完全独立于数据库应用系统，无须改动数据库应用系统就能实现数据加密功能；第三，加解密处理在客户端进行，不会影响数据库服务器的效率。</p> <p> 数据库加/脱密引擎是数据库加密系统的核心部件，它位于应用程序与数据库服务器之间，负责在后台完成数据库信息的加/脱密处理，对应用开发人员和操作 人员来说是透明的。数据加/脱密引擎没有操作界面，在需要时由操作系统自动加载并驻留在内存中，通过内部接口与加密字典管理程序和用户应用程序通讯。数据 库加/脱密引擎由三大模块组成：加/脱密处理模块、用户接口模块和数据库接口模块，如图4所示。其中，&quot;数据库接口模块&quot;的主要工作是接受用户的操作请 求，并传递给&quot;加/脱密处理模块&quot;，此外还要代替&quot;加/脱密处理模块&quot;去访问数据库服务器，并完成外部接口参数与加/脱密引擎内部数据结构之间的转换。&quot; 加/脱密处理模块&quot;完成数据库加/脱密引擎的初始化、内部专用命令的处理、加密字典信息的检索、加密字典缓冲区的管理、SQL命令的加密变换、查询结果的 脱密处理以及加脱密算法实现等功能，另外还包括一些公用的辅助函数。</p> <p> 数据加/脱密处理的主要流程如下：</p> <p> 1） 对SQL命令进行语法分析，如果语法正确，转下一步；如不正确，则转6），直接将SQL命令交数据库服务器处理。</p> <p> 2） 是否为数据库加/脱密引擎的内部控制命令？如果是，则处理内部控制命令，然后转7）；如果不是则转下一步。</p> <p> 3） 检查数据库加/脱密引擎是否处于关闭状态或SQL命令是否只需要编译？如果是则转6），否则转下一步。</p> <p> 4） 检索加密字典，根据加密定义对SQL命令进行加脱密语义分析。</p> <p> 5） SQL命令是否需要加密处理？如果是，则将SQL命令进行加密变换，替换原SQL命令，然后转下一步；否则直接转下一步。</p> <p> 6） 将SQL命令转送数据库服务器处理。</p> <p> 7） SQL命令执行完毕，清除SQL命令缓冲区。</p> <p> 以上以一个例子说明了在DBMS外层实现加密功能的原理。</p> <p>5. 结束语</p> <p> 本文对数据库系统安全防入侵技术进行综述，提出了数据库系统的安全体系三个层次框架，并对三个层次的技术手段展开描述。文中还以在DBMS外层实现加密功能的原理为例，详细说明了如何应用数据库管理系统层次的安全技术。</p> <p> 数据库系统安全框架的三个层次是相辅相承的，各层次的防范重点和所采取的技术手段也不尽相同，一个好的安全系统必须综合考虑核运用这些技术，以保证数据的安全。</p> <p>----------------------------------------------------------------------------------------------------------------------------</p> <p>数据库安全分析</p> <p>三大安全风险</p> <p>数据库是任何商业和公共安全中最具有战略性的资产，通常都保存着重要的商业伙伴和客户信息，这些信息需要被保护起来，以防止竞争者和其他非法者获 取。互联网的急速发展使得企业数据库信息的价值及可访问性得到了提升，同时，也致使数据库信息资产面临严峻的挑战，概括起来主要表现在以下三个层面：</p> <p>管理层面：主要表现为人员的职责、流程有待完善，内部员工的日常操作有待规范，第三方维护人员的操作监控失效等等，致使安全事件发生时，无法追溯并定位真实的操作者。</p> <p>技术层面：现有的数据库内部操作不明，无法通过外部的任何安全工具（比如：防火墙、IDS、IPS等）来阻止内部用户的恶意操作、滥用资源和泄露企业机密信息等行为。</p> <p>审计层面：现有的依赖于数据库日志文件的审计方法，存在诸多的弊端,比如:数据库审计功能的开启会影响数据库本身的性能、数据库日志文件本身存在被篡改的风险，难于体现审计信息的真实性。</p> <p>伴随着数据库信息价值以及可访问性提升，使得数据库面对来自内部和外部的安全风险大大增加，如违规越权操作、恶意入侵导致机密信息窃取泄漏，但事后却无法有效追溯和审计。</p> <p>传统数据库安全方案缺陷</p> <p>传统的审计方案，或多或少存在一些缺陷，主要表现在以下两个方面。</p> <p>传统网络安全方案：依靠传统的网络防火墙及入侵保护系统(IPS)，在网络中检查并实施数据库访问控制策略。但 是网络防火墙只能实现对IP地址、端口及协议的访问控制，无法识别特定用户的具体数据库活动(比如：某个用户使用数据库客户端删除某张数据库表);而 IPS虽然可以依赖特征库有限阻止数据库软件已知漏洞的攻击，但他同样无法判别具体的数据库用户活动，更谈不上细粒度的审计。因此，无论是防火墙，还是 IPS都不能解决数据库特权滥用等问题。</p> <p>基于日志收集方案：需要数据库软件本身开启审计功能，通过采集数据库系统日志信息的方法形成审计报告，这样的审计方案受限于数据库的审计日志功能和 访问控制功能，在审计深度、审计响应的实时性方面都难以获得很好的审计效果。同时，开启数据库审计功能，一方面会增加数据库服务器的资源消耗，严重影响数 据库性能;另一方面审计信息的真实性、完整性也无法保证。</p> <p>其他诸如应用程序修改、数据源触发器、统一认证系统授权等等方式，均只能记录有限的信息，更加无法提供细料度的数据库操作审计。</p> <p>--------------------------------------------------------------------------------------------------------------------------</p> <p>安全审计</p> <p>一、数据库安全审计系统主要功能包括：</p> <p> · 实时监测并智能地分析、还原各种数据库操作。</p> <p> · 根据规则设定及时阻断违规操作，保护重要的数据库表和视图。</p> <p> · 实现对数据库系统漏洞、登录帐号、登录工具和数据操作过程的跟踪，发现对数据库系统的异常使用。</p> <p> · 支持对登录用户、数据库表名、字段名及关键字等内容进行多种条件组合的规则设定，形成灵活的审计策略。</p> <p> · 提供包括记录、报警、中断和向网管系统报警等多种响应措施。</p> <p> · 具备强大的查询统计功能，可生成专业化的报表。</p> <p> 二、数据库安全审计系统主要特点</p> <p> · 采用旁路技术，不影响被保护数据库的性能。</p> <p> · 使用简单，不需要对被保护数据库进行任何设置。</p> <p> · 支持SQL-92标准，适用面广，可以支持Oracle、MS SQL Server、Sybase、Informix等多类数据库。</p> <p> · 审计精细度高，可审计并还原SQL操作语句。</p> <p> · 采用分布式监控与集中式管理的结构，易于扩展。</p> <p> · 完备的&quot;三权分立&quot;管理体系，适应对敏感内容审计的管理要求。</p> <p>----------------------------------------------------------------------------------------------------------------------</p> <p>安全审计技术分类</p> <p>常见的安全审计技术主要有四类，分别是：基于日志的审计技术、基于代理的审计技术、基于网络监听的审计技术、基于网关的审计技术。</p> <p> 1.基于日志的审计技术：该技术通常是通过数据库自身功能实现，Oracle、DB2等主流数据库，均具备自身审计功能，通过配置数据库的自审计功能，即可实现对数据库的审计，其典型部署示意图如图2所示：</p> <p> 图2 日志审计技术部署示意</p> <p> 该技术能够对网络操作及本地操作数据库的行为进行审计，由于依托于现有数据库管理系统，因此兼容性很好。</p> <p> 但这种审计技术的缺点也比较明显。首先，在数据库系统上开启自身日志审计对数据库系统的性能就有影响，特别是在大流量情况下，损耗较大；其 次，日志审计记录的细粒度上差，缺少一些关键信息，比如源IP、SQL语句等等，审计溯源效果不好，最后就是日志审计需要到每一台被审计主机上进行配置和 查看，较难进行统一的审计策略配置和日志分析。</p> <p> 2.基于代理的审计技术：该技术是通过在数据库系统上安装相应的审计Agent，在Agent上实现审计策略的配置和日志的采集，常见的产品 如Oracle公司的Oracle Audit Vault、IBM公司的DB2 Audit Management Expert Tool以及第三方安全公司提供的产品，其典型部署示意图如图3所示：</p> <p> 图3 代理审计技术部署示意</p> <p> 该技术与日志审计技术比较类似，最大的不同是需要在被审计主机上安装代理程序。代理审计技术从审计粒度上要优于日志审计技术，但是性能上的损 耗是要大于日志审计技术，因为数据库系统厂商未公开细节，由数据库厂商提供的代理审计类产品对自有数据库系统的兼容性较好，但是在跨数据库系统的支持上， 比如要同时审计Oracle和DB2时，存在一定的兼容性风险。同时由于在引入代理审计后，原数据库系统的稳定性、可靠性、性能或多或少都会有一些影响， 实际的应用面较窄。</p> <p> 3.基于网络监听的审计技术：该技术是通过将对数据库系统的访问流镜像到交换机某一个端口，然后通过专用硬件设备对该端口流量进行分析和还原，从而实现对数据库访问的审计。其典型部署示意图如图4所示：</p> <p> 图4 网络监听审计技术部署示意</p> <p>该技术最大的优点就是与现有数据库系统无关，部署过程不会给数据库系统带来性能上的负担，即使是出现故障也不会影响数据库系统的正常运行，具备易部署、无 风险的特点；但是，其部署的实现原理决定了网络监听技术在针对加密协议时，只能实现到会话级别审计（即可以审计到时间、源IP、源端口、目的IP、目的端 口等信息），而没法对内容进行审计。不过在绝大多数业务环境下，因为数据库系统对业务性能的要求是远高于对数据传输加密的要求，很少有采用加密通讯方式访 问数据库服务端口的情况，故网络监听审计技术在实际的数据库审计项目中应用非常广泛。</p> <p> 4.基于网关的审计技术：该技术是通过在数据库系统前部署网关设备，通过在线截获并转发到数据库的流量而实现审计，其典型部署示意图如图5所示：</p> <p> 图5 网关审计技术部署示意</p> <p> 该技术是起源于安全审计在互联网审计中的应用，在互联网环境中，审计过程除了记录以外，还需要关注控制，而网络监听方式无法实现很好的控制效 果，故多数互联网审计厂商选择通过串行的方式来实现控制。在应用过程中，这种技术实现方式开始在数据库环境中使用，不过由于数据库环境存在流量大、业务连 续性要求高、可靠性要求高的特点，与互联网环境大相径庭，故这种网关审计技术往往主要运用在对数据库运维审计的情况下，不能完全覆盖所有对数据库访问行为 的审计。</p> <p class="read-more">Continue reading <a class="heading" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/e6-95-b0-e6-8d-ae-e5-ba-93-e7-b3-bb-e7-bb-9f-e5-ae-89-e5-85-a8-e6-8a-80-e6-9c-af-e6-a1-86-e6-9e-b6-e7-bb-bc-e8-bf-b0.html" data-flip="title">数据库系统安全技术框架综述</a></p> </article> <article id="post-%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/%e3%80%90%e8%bd%ac%e3%80%91%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%9c%e7%a8%8b%e5%a4%8d%e5%88%b6%e5%92%8c%e5%bc%82%e5%9c%b0%e5%ae%b9%e7%81%be-%e5%a4%a7%e8%ae%a8%e8%ae%ba" class="post mb6" role="article"> <header> <h1 class="post-title"> <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/e3-80-90-e8-bd-ac-e3-80-91-e6-95-b0-e6-8d-ae-e5-ba-93-e8-bf-9c-e7-a8-8b-e5-a4-8d-e5-88-b6-e5-92-8c-e5-bc-82-e5-9c-b0-e5-ae-b9-e7-81-be-e5-a4-a7-e8-ae-a8-e8-ae-ba.html" data-flip="title"> 【转】数据库远程复制和异地容灾 大讨论 </a> </h1> <p class="post-date heading"> <time datetime="2011-05-30T16:03:47+08:00">30 May 2011</time> in <span>数据库</span> on <span>数据库</span> </p> <div class="hr" style="padding-bottom:0"></div> </header> <p>最近发现论坛上关于数据库远程复制和异地容灾等问题的帖子比较多，现在把我知道的一些解决方案进行一下分析，能力有限，还希望大家多多补充、纠正！<img src="/assets/KNw7VUeyjZ9ZOifkWnnAs0DMH58paCWUMFpy8TENa0Jo-0wWyh4NLXtksw9DwzFJ_1XIUW3DZWnp_tdI__tK4E7w7ZHHoiC_8m53AHaUt_WxqQRSTA" width="20" height="20" /> <br />目前，针对oracle数据库的远程复制、容灾主要有以下几种技术或解决方案： <br />（1）基于存储层的容灾复制方案 <br />这 种技术的复制机制是通过基于SAN的存储局域网进行复制，复制针对每个IO进行，复制的数据量比较大;系统可以实现数据的同步或异步两种方式的复制.对大 数据量的系统来说有很大的优势（每天日志量在60G以上）,但是对主机、操作系统、数据库版本等要求一致，且对络环境的要求比较高。 <br />目标系统不需要有主机，只要有存储设备就可以，如果需要目标系统可读，需要额外的配置和设备，比较麻烦。 <br />（2）基于逻辑卷的容灾复制方案 <br />这 种技术的机制是通过基于TCP/IP的网络环境进行复制，由操作系统进程捕捉逻辑卷的变化进行复制。其特点与基于存储设备的复制方案比较类似，也可以选择 同步或异步两种方式，对主机的软、硬件环境的一致性要求也比较高，对大数据量的应用比较有优势。其目标系统如果要实现可读，需要创建第三方镜像。个人认为 这种技术和上面提到的基于存储的复制技术比较适合于超大数据量的系统，或者是应用系统的容灾复制。 <br />我一直有一个困惑，存储级的 复制，假如是同步的，能保证 数据库所有文件一致吗 ？或者说是保证在 异常发生的那一刻有足够的缓冲来保障？ <br />也就是说，复制的时候起文件写入顺序和oracle的顺序一致吗？如果不一致就可能有问题，那么是通过什么机制来实现的呢？ <br />上次一个存储厂商来讲产品，我问技术工程师这个问题，没有能给出答案 <br />我对存储级的复制没有深入的研究过，主要是我自己的一些理解，你们帮我看一下吧……<img src="/assets/GN_UluPXy5VdXw-oP6sj90X4z5jOt7UxlSiYmNLFC6PulG8WzmGAXIlt9JTZOSxsGFZsjFqm2YbkHnDQPiYWX41Pj2NKnHEogO7gaU-Q1JUxwEA8MQ" width="20" height="20" /> <br />我 觉得基于存储的复制应该是捕捉原系统存储上的每一个变化，而不是每隔一段时间去复制一下原系统存储上文件内容的改变结果，所以在任意时刻，如果原系统的文 件是一致的，那么目标端也应该是一致的，如果原系统没有一致，那目标端也会一样的。形象一点说它的原理可能有点像raid 0，就是说它的写入顺序应该和原系统是一样的。不知道我的理解对不对。另外，在发生故障的那一刻，如果是类似断电的情况，那么肯定会有缓存中数据的损失， 也不能100%保证数据文件的一致。一般来说是用这种方式做oracle的容灾备份，在发生灾难以后目标系统的数据库一般是只有2/3的机会是可以正常启 动的（这是我接触过的很多这方面的技术人员的一种说法，我没有实际测试过）。我在一个移动运营商那里看到过实际的情况，他们的数据库没有归档，虽然使用了 存储级的备份，但是白天却是不做同步的，只有在晚上再将存储同步，到第二天早上，再把存储的同步断掉，然后由另外一台主机来启动目标端存储上的数据库，而 且基本上是有1/3的机会目标端数据库是起不来的，需要重新同步。 <br />所以我觉得如果不是数据量大的惊人，其他方式没办法做到同步，或者要同时对数据库和应用进行容灾，存储级的方案是没有什么优势的，尤其是它对网络的环境要求是非常高的，在异地环境中几乎不可能实现。 <br />不知道我的理解对不对，也不知道是不是回答了你的问题，呵呵。欢迎指正！<img src="/assets/Dt_3fBTFV_eUe8izekiMDpPq_2cj1cDaU6FwnDcIjnL9tGyrWFr0UMfZZRfbQ1Z6CRXgkrnAh9BH1j_ZqJJLMalFTDNZxLTUwS1pkfstF4uf6BEtVw" width="20" height="20" /> <br />应该说部分地回答了我的问题，呵呵 <br />因为 实际上存储设备的写入顺序 和 oracle 的进程的写入顺序肯定是不一样的，存储设备一定是做过重整的，那 不管同步或者异步的拷贝都 有可能 存在问题的。 <br />所以我一直对这个方案的可靠性不敢完全相信，这样一来，倒不如 data guard 可靠了 <br />因为很明显，存储设备拷贝过去的数据文件 不一致是有很大的概率的 <br />你 的意思是说即使不考虑目标端，仅在源端的情况下，存储设备的写入顺序也是和Oracle不一致的？这应该是一个原因。我觉得还有一种可能性就是在忽略存储 设备的这种情况下，在主系统当机，发生切换的时候，主系统存储上的数据文件也不一定能保证一致，就算目标系统保持了完全的同步，也一样不能保正目标端数据 可可以启动。 <br />不太理解，为什么说存储设备的写入顺序会和oracle进程的写入顺序不一致阿 <br />如果说仅在源端情况下，存储设备的写入顺序也是和Oracle进程不一致，那么不考虑异地冗灾，那么是不是意味着即使本地服务器crash，也无法启动存储上的数据文件？ <br />我也有这个疑问，以前一直觉得仅考虑主系统的情况下，存储设备的写入顺序应该是和数据库的写入顺序一致的， 但我觉得biti_rainy的理解也是有道理的，存储设备毕竟和一般的磁盘不一样，很可能再写入的时候会作重新的组合，不过不知道具体的证据是什么啊？ <br />按 照这种理解，再写入的某一瞬间，数据库的写入顺序和存储的写入顺序可能是不一致的，但既然存储写入的结果跟oracle的写入结果肯定是一致的，那么我们 可以把一个比较长的写入过程分成若干个时间段，在每个时间段的结尾，oracle和存储设备的写入结果都是完全一致的，那么这个时间段的大小是多少呢？ <br />呵呵，说得我自己都快晕了，也不知道大家明白我的意思没有…… <br />o <img src="/assets/_38QHe4Pfxtsa2kn6V3wIZX9tLSxFRNMS-mSv3HzcTRgCk5fMmKWOPIddU-j6wt4qZac9yJ6QFyjSQGvczDLskixeBiospvWAf1XmOgZEWIxMzwR_Q" width="20" height="20" /><img src="/assets/1oLl2IWeGg_4rfo2kXXDd6qoGaQC5c77DxsUR5TOzJkSoR8mDJTK0IeHbtcTSgYaBzru7CVEvwN0nYL3MB3HhFLHdZMyuW9bCfgcntJalsOJRLvc5w" width="20" height="20" /><img src="/assets/3YUpYde_jCV7JolXLC0h2MlWF3w83g3rtx-ZrgOMFa-4zyy8ld1qleIreyeb8Li28_nFdFvpGiSLlYxtPCfxgKJwgOWs3Xe94rU2_yf9sMYXEBvsFg" width="20" height="20" /> <br />biti_rainy能不能给我们解释一下啊？或者论坛里有没有对存储设备比较了解的兄弟啊？<img src="/assets/JTzlHhfqG6gNC5KzYdsflK8NK5Da86XMFxwGZE-AEBkr0fv0CWQWAT-urKM-ynn1UVBwt5-0Sfaq7H4_KKIrbLK5Nj94sqNGolBcgY2I9AKIr3VN5w" width="20" height="20" /><img src="/assets/gT3_HCzVzrSnIeBOUoKgAt83xV1cVOmiDyTQ8K-mVxa6uo55Bw03CTx9hcYSzkfobVCLxV9oBoZUhi5bYGG73faXsu7ut1xfln3jfo4gy_vRSBxM_w" width="20" height="20" /> <br />系统上通常不一致没关系是因为还有 logfile 的存在，而日志文件通常是被写入了磁盘的，oracle本身是顺序写的，还不需要读，应该是被重整的几率比较小 <br />还有存储设备上，比如掉电没关系，是因为存储设备都有足够的短时间供电能力使得 cache 中的数据能被写入磁盘，这个如果不能保证那一掉电基本都要出问题的 <br />但是在复制的那端，我就不清楚是怎么处理的，比如我要停掉复制，开始用起这数据来，或者说设备掉电了，这个时候是怎么处理的 <br />在复制的那端，我感觉是没有经过特殊处理的，因为存储设备完全是物理上的同步，在你停掉 复制的时候，他最多只能保证在停止复制或原系统掉电的这一刻所有文件在物理上是和原系统的存储是完全一致的，但他绝对不会去校验或保证oracle的数据 文件在逻辑上是否一致，所以会造成复制端在停止复制后有很大几率不能正常启动。我在客户那的情况就是在原系统正常运行的情况下，停止存储的复制，然后启动 目标端数据库，但还是有1/3的几率无法启动，如果是在原系统发生故障或断电的情况下，估计就更不好说了。 <br />我还是比较佩服那个客户的勇气，一个省级移动运营商的数据中心，数据库连归档都没有，一旦系统崩溃，至少要损失当天的数据，同时容灾端的数据库能不能起来还是个问题…… <br />还好目前还没有出问题，要是出了问题，不知道他们会怎么办…… <br />上次做存储设备的来公司，谈到这个问题的时候说： 很多客户就是这么做的 <br />我就说： 很多人这么做的并不能说就没问题，因为很多 人没有出现事故，是因为隐藏的问题没有机会暴露出来。我需要： <br />1：机制上的可靠保障，这个可能只有非常理解 原理的人能回答 <br />2：实际系统的测试，要经过在我们自己提供的数据场景下反复测试 <br />通过这两点之后我们才敢放心使用 <br />同意，确实很多人都是这么用的，也确实都很可能出现问题，所以我一直以为基于存储的数据 库容灾方案是有问题的，但在有些环境中好像还只能这么做，例如我们的一个客户，也是一个省级的移动运营商，其数据库每天的日志量达到100G以上，在这种 条件下，好像只有这种解决方案比较可行，其他的都会有一些问题，至少那些使用软件实现的逻辑复制方案是不行的，我感觉oracle自己的standby好 像也负担不了吧？不过他们的数据库至少还是归档的，还有一点保证。呵呵。 <br />从ORACLE的角度来衡量基于存储的容灾肯定是有问题的，不可能做到100%可用。 <br />即使是ORACLE的DATA GUARD也不能保证100%没有数据丢失（当前日志组的数据）。 <br />换个思路了，使用基于应用的同步方案吧。 <br />（3）基于oracle redo log的逻辑复制方式 <br />使用这种方式的主要有一些第三方的软件，以及oracle自己的DATAGUARD 中的logical Standby。先介绍一下第三方的软件产品吧……<img src="/assets/b2QfnhihTQ_f1Xf59fH1ply6HOvAHArxSmkZJoZBMXdslw6ge720vGnlpTe9mnghkCK39EvHSHfGW0UpR-ubXMrUd0ZrgwusibfYYqrdJ-19x0K_zQ" width="20" height="20" /> <br />目前，国外已经有了很多比较成熟的产品及成功案例，国内也有类似的产品， 但在产品的成熟程度和成功案例上跟国外还有一定的差距。 <br />这类产品的原理基本相同，其工作过程可以分为以下几个流程： <br />使 用oracle以外的独立进程，捕捉redo log file 的信息，将其翻译成sql语句，再通过网络传输到目标端数据库，在目标端数据库执行同样的sql。如果其进程赶不上oracle日志切换，也可以捕捉归档 日志中的内容。也有的产品在源端以事务为单位，当一个事务完成后，再把它传输到目标端。所有的产品一般都是以表为单位进行复制，同时也支持大部分DDL的 复制（主要在oracle9i环境中）。 <br />这种技术的技术特点和优势主要有以下几点： <br />目标端数据库一直是一个可以访问的数据库； <br />能保证两端数据库的事务一致性； <br />因为使用oracle以外的进程进行捕捉，且其优先级低于oracle进程，所以对源系统数据库的性能影响很小； <br />基于其实现原理及多个队列文件的使用，复制环境可以提供网络失败、数据库失败、主机失败的容错能力； <br />因为这类软件复制的只是sql语句或事务，所以他可以完全支持异构环境的复制，硬件的型号，oracle的版本，操作系统的种类、版本等都没有要求。 <br />这种方式还可以支持多种复制方式，比如数据集中、分发、对等复制、或者多层测的复制等。 <br />由于传输的内容只是redolog 或archive log中的一部分，所以对网络资源的占用很小，可以实现不同城市之间的远程复制。 <br />基于redolog的逻辑复制产品有很多的优势，但跟上面提到过的其他方案比较起来，也有一些缺点： <br />数据库的吞吐量太大时，其实据会有较大的延迟，当数据库每天的日量达到60G或更大时，这种方案的可行性交差； <br />实施的过程可能会有一些停机时间，来进行数据的同步和配置的激活； <br />复制环境建立起来以后，对数据库结构上的一些修改需要按照规定的操作流程进行，有一定的维护成本。 <br />不过目前这类产品的发展很快，上面的这些问题，在大部分产品的最新版本中都有很大的改进。 <br />您说的备中心1/3机会不可用，是同步复制还是异步复制的情况？ <br />是指同步复制的情况。 <br />这个数字我不敢保证它的准确性，因为我没有做过实际的实验来验证，但从我在客户那里看到的实际情况来说，基本属实。 <br />您能告诉我你的客户用的那一家的产品吗？ <br />不 管是同步环是异步只要不是在数据库里面做宕机时总应该有数据不一致的情况吧 因为数据库写文件是由操作系统来最终完成的，而操作系统本身又有cache，在通过逻辑复制把数据异步或同步复制到其他存储设备上，中间无论哪个环节有问 题，远程存储设备的数据都不能同现有数据保持一致，所以我认为 biti的怀疑是很有道理的。到10g oracle可以使用assm，直接同存储设备对话，这样是否能够好一些，不太确定 <br />存储是通过快照来记录状态，然后再进行复制进行备份的。 <br />其实最好的方法应该是捕捉redo log file 的信息，将其翻译成sql语句 <br />这就是oracle stream 和quest shareplex实现的功能 <br />利用oracle 9i的高级复制，加上第三方的管理工具就可以了 <br />我对oracle 的高级复制研究较多，觉得这是最好的方法，能够完全保证数据的一致性。 <br />但管理起来比较麻烦，需要利用第三方的管理工具就可以了。我用的是 深圳华尔东城公司的管理工具，能够自动进行简单故障处理，目前设置的10分钟增量同步，最大表有4000多万条记录，目前还只同步了一部分表，数据量达到了50G。 <br />容灾实际例子，不知道是不是有帮助 <br />曾 经评估了几个这方面的方案，一是利用存储本身提供的功能，在两端距离比较远（几百几千公里）的时候，只能用异步的方式，同步的话对网络的带宽要求很高，除 非两端能够用光纤直接连接。异步的方式根据厂商的解释是这样的，远端存储上的写是无序的，不会根据生产端的次序写入，对用户来说是透明的，没有办法干预， 也就是说对oracle来说是不同步的，如果没有人为的干预进行一次同步的话，数据库也没有办法启动。但是如果要同步的话就会对生产数据库产生影响，处于 suspend状态。至于停电等各种极端情况我们在同城同步做过测试，没有问题，存储能够保证数据的一致和可用。异地异步没有测试过，不知有哪位兄弟做过 这个试验，能告诉结果。 <br />看了大家的帖子，我也想说点东西，一直以来做的就是容灾和备份的事情。 <br />目前的所谓的容灾可能包含两种方式： <br />1.真正的容灾，目的就是为了防止在灾难发生的时候能减少下线时间。这个过程没有一个能做到零下线的。 <br />2.”假“容灾，即所谓的ods，数据复制。出来的数据不单单能达到容灾的目的，而且目的端数据可以实时被使用。 <br />第一种方式可能是鸡肋，因为花那么大的投资使用当前的硬件容灾方式去达到一个可能领导在任期间都不能发生的灾难，实在让人觉得不太值得，除非厂商给了这个领导很大一笔钱，不过当前许多电信行业都说要建容灾中心。 <br />第二种方式确实是一种很诱人的方式，也是我现在做的产品。这种方式主要采用两种方式实现： <br />a.使用我们现在的同步工作实现首次同步（逻辑上的导出，也是一种鬼才写出了这个东西，当然他是我们老总），然后直接转入监控online redolog进行日志监控分析转化，然后传送到目标端装载。 <br />b.使用类似于bcv/ca/flashcopy这些快照类软件在磁盘存储级做成首次同步，然后使用我现在的产品做日志监控，加载到目的端。 <br />这个产品作了1年多，应该说比quest的shareplex强大的多了，但是我并非在此宣传产品，所以我要说的是公平话。 <br />通 过oracle内部方式去达到实时同步可能本身就是一个错误，类似于oracle本身的advance replication以及data guard也是日志分析方式的，他的主要缺点在于效率上存在问题，就是装载数据量很大的时候，根本不能应付，这也是shareplex的毛病。因此我现在 的产品在这个上面是克服了这些缺点，效率绝对的高。我和oracle的stream，quest的shareplex，以及非用于容灾方式的data guard等对比过，大家互有长短。 <br />关键就是，采用基于这种精确分析的复制方式，如何保证数据是完全准确的： <br />1.没有有效的检验方式，检查数据是否一致，有类似于select minus select的方式，但是对于超过100M的表，除非你有足够的耐心，我经常见到表最大是92G，没有分区，很变态。 <br />2.就算你知道了丢失数据，如何把这个数据补回来。现在的类似于我们的软件，都采用了rowidmap的方式去做精确定位，所以如果丢失了，你如何补回来。我知道quest 是重新同步，我们是把整个表重新同步，因为我们的逻辑到处快。 <br />这些都是基于oracle精确复制需要解决的最大的问题。 <br />呵呵，当然了关于这个里面处理很多oracle的特殊操作的时候还有很多需要做的事情，quest做了8年多了吧，到5年后才支持chained row，不能不说这是一个悲剧。还有许多的操作类型怎么办：ddl <br />,truncate,rollback savepoint,nologging等等，当然日志了没有的时候，你如何做。 <br />我个人的观点，基于oracle的精确分析复制方式，除了oracle以后能做好，其他人不要轻易尝试。 <br />不知道能否把产品名字透露一下啊？ <br />如果没有猜错应该是DSG的了？ <br />DGS和shareplex的比较让市场来说话吧。 <br />每个人都会说自己的产品好，但是希望在itpub这个地方 <br />还是要说出一些更多技术上的东西。 <br />samchj说“此我现在的产品在这个上面是克服了这些缺点，效率绝对的高”，并且也提到你们的产品也是通过监控redo的变化，提取SQL，那么为什么你们的效率会绝对的高？ <br />希望能从机制上说明一下这个问题。 <br />首先我澄清一下，我没有宣传产品的意思。 <br />我必须让事实说话，而不是市场说话，市场存在很多人为因素。 <br />在 效率上，对于处理chained row这种在数据库中经常出现的东西，不能采用sql statment执行的方法。而shareplex是使用的这种方法。曾经我在测试的时候就对比过这个东西。因为chained row 包括migrate row &amp;chain row 两种。而mr在oracle中只有一个rowid，而cr却不止。因此如果你采用的是rowmap方式精确定位两边的表，那么在处理chain row的时候，除非你能很好的处理，否则最简单和准确的方式就是直接在源端找到这个行，然后通过sql statment的方式装到目的端。这样在速度上是很慢的。 <br />效率的提高主要从分析速度和装载速度上讲的。 <br />我不知道shareplex日志分析是如何进行的，这当然也是这类型软件的kernel了，这是算法问题，我想起基本原理和logminer都差不多，在算法上优化分析速度是很重要的。 <br />在 装载问题上，其实shareplex也曾经使用过direct path的装载方式，但是因为direct path本身就存在很多bug，因此干脆就放弃了这种方式，因为据我所接触的通过direct path装载的bug就很多，例如索引不能使用等。所以只能通过conventional path来装载。这就是规规矩矩的转换成sql statment，然后交给oracle通过解释成binary 后在装载 <br />了，这是很浪费时间的，而且对于qmi（基本由creat table as select引起的oracle特殊插入处理）来说，这是很不合理的，因此在这里应该做些事情，当然细节不便于说。 <br />另外对于首次同步的导出和装载，现在的oracle10g也许就是使用的这种方式了，你可以看看oracle10g的export为什么如此快。 <br />我还是说，不论是否市场怎么样，使用基于oracle精确分析装载的软件要慎重使用，因为他的问题是很多的。 <br />楼上的你们产品是什么啊 <br />关于这类产品的一些特别情况的处理我一直很关心 <br />另： 10G 使用的 *expdp* 和 *impdp* 应该是由 DUL + SQLLDR direct 思想的结合吧 <br />我们现在用的是Oracle 9i ，想用复制软件VERITAS Storage Replicator 3.0使两台服务器上的数据库同步，应该复制Oracle下的那些数据文件，表空间？还有复制后应该怎么做？ <br />服务器硬件说明： <br />两台服务器为了节约成本，没有使用双机热备，没用磁盘阵列，每台服务器用4块SCSI硬盘做成Raid 5，两台服务器操作系统，数据库安装路径，设置都一致，有没有解决办法啊? <br />使用SQL Server 2000数据库把数据文件复制到另外一台服务器，数据库可以实现同步，但是Oracle 9i把一台服务器上的表空间复制到另一台服务器后数据库不用能。 <br />对于samchj 一直说：然后通过sql statment的方式装到目的端。这样在速度上是很慢的，然后交给oracle通过解释成binary 后在装载了，这是很浪费时间的 ？ <br />－－－－－－－－－－－－－－－－－－－－－－－－ <br />能否举出实际的例子？拿出具体的数据来说话， 你所谓的慢是什么程度？ <br />澄清一下，shareplex 不是使用你所谓的direct path 方式。 <br />dx6340老兄，我不是在宣传产品，我再澄清一次。如果有人对我现在做的产品感兴趣，可以给我写邮件，但是我们只谈技术，不谈市场，但是在itpub上或者任何其它场合，我不会说我的产品是如何的好，虽然我的和shareplex做的对比测试很多。他们各有各的优缺点。 <br />shareplex 确实不使用direct path装载，这个我也说过“其实shareplex也曾经使用过direct path的装载方式”，我是说曾经，从研发上讲。你可以用shareplex或者oracle的data guard等做实验，当大数据量的时候，你可以看看他是否能分析过来和装载过来，延迟时间多少。一秒钟能支持的update有多少，insert有多少， 如果做ddl是否需要先停止复制。这些还只是很基本的处理。logminer尚且对日志的分析很慢（不过可以用多进程来弥补，如果你有很多的系统资源）。 <br />wbo 兄弟的“Oracle 9i把一台服务器上的表空间复制到另一台服务器后数据库不用能。”，我的理解是，如果你使用基于存储级的复制产品，你同步的应该是整个设置的卷或者卷组， 他没有什么oracle的逻辑结构复制方法吧，要么就是把这个表空间创建在一个卷组上，然后设定复制这个卷组。如果你硬是要复制一个表空间过去，我觉得你 应该先通过oracle的TRANSPORT_TABLESPACE来，但是好像很没有必要。使用存储级的复制不能实时打开，打开必须断开。 <br />对于基于复制中的特殊方式处理，主要有这些： <br />1.采用何种装载方式 <br />2.如何准确快速执行delete和update，因为这两个操作需要rowid，有人采用在数据库本身创建很多的表来维护rowid。 <br />3.对chain row的处理 <br />4.对各种ddl的处理(truncate,create,drop,alter) <br />5.对于未提交的事务的处理 <br />等等,因为我确实还没有来总结这些资料,这里先列各提纲,我一个一个来总结. <br />1.装载方式: <br />在 oracle中装载数据库不外乎两种方式:direct path和conventinal path装载,其中类似direct path装载就是例如sqlload等工具使用的装载方式,因为它省去了sql语句的编译\绑定(kk/kx),直接转换成绑定后的格式对extent进 行操作.而conventinal path装载方式确实普通的装载方式,即类似于标准的sql语句的装载.后者比前者在同等条件下要慢5倍.当然两种方式的装载速度还和表本身的结构和大小 有关.我测试的速度最大有12倍的差距. <br />在装载上,你还要考虑更多内容,你不能单单调用oracle sqlloader,因为在oracle中有很多的oracle特殊处理的东西,例如:qmi,qmd.oracle在这里对于这些操作有在redo中有 特殊的标志,如果你采用create table as select来创建表,你会觉得它比现创建然后用sql语句插入要快的多,在日志中他也只有很少的记录.因此,在处理这些的时候,你要采用特殊的算法,所 以调用oracle的现成工具是不理想的,曾经在oracle7之前oracle并没有将upi (好像是这个名字)封掉,但是在oracle8i后,oracle不再开放该接口,因此很多的程序员对于这个层面了解很少.当然现在你很难找到.oci只 是封装后更高级的接口而已. <br />因此装载程序的设计,对于基于oracle精确分析方式的复制有很大的决定作用,这里面还有更多的处理,我也不能一一列出了. <br />呵呵，楼上的这个工具就是你自己开发的吗？ <br />如果你老板能找到一个肯研究 OCI --&gt; UPI ---&gt;OPI 的手下 并一直坚持对oracle的研究，在国内简直是太不容易了。 <br />没其他意思,如果不是你开发的，除了对这一部分外，对oracle的整体问题你有过研究吗？ <br />呵 呵，我不知道oracle的整体问题是什么意思，oracle太大了，我涉及的有关于oracle的备份恢复（包括非归档物理热备份，各种恢复方式，以及 你们都已经在讨论的热备到底在做什么，那都是我很早前学的，反正备份的东西夸大点就是知道原理的东西多些，不过不敢在任何地方卖弄，因为技术这个东西很难 说，嘻嘻）。 <br />搞我们这个容灾产品也有很久了，基本涉及的有联机日志分析，各种特殊操作的原理等等，不能详细罗列，但是在装载上说实话，我只是知道 经过哪些层次，并没有开发，而是帮助开发作单元测试，所以知道比较详细些而已，知道对于我上面写的东西如何处理。同时对比过诸 如：shareplex，stream，data guard等软件产品性能和基本的一些原理，也和存储级复制软件结合，做过组合测试而已。 <br />对于oracle的调优工作，我还是不如大家的，不过我看eygle老兄的东西都很接近我学的东西，因为确实我曾经站在了“巨人”的肩膀上，嘻嘻，还要向大家多学习，学习。 <br />要说深入oracle，也只是在看大家写的东西的同时，自己总结在这些年学习的东西，和大家分享，因为我觉得，我在网络上学了些，当然我也想将我学到的东西给大家分享，呵呵。 <br />明天继续对于这种产品存在的各种瓶颈作分析，也希望大家指正，我申明一点，我不做产品宣传，只是在我都测试过的基础上总结，绝不胡说 <br />其实也没什么,整体方面是说oracle的文件、内存、进程等比较全面的东西， <br />对于 oracle internal 比较有兴趣一些，如 oracle 内存、文件管理、进程间通信 <br />宏观方面 备份恢复、tuning、体系结构 ，这些都是在前面internal基础上的具体应用，了解了internal后在管理方面就不局限于固定的模式了。 <br />比如喜欢这样的探讨： <br />呵呵，当然，我关注的也是这些。 <br />我努力想成为一个像我们老板一样的高手，他能将这些东西转换成程序，呵呵。 <br />但是我不能把他拉到itpub上来，否则，中国的oracle研究者有福了。不过我愿意将我在他那里学的东西共享给大家，和大家一起研究。也请多指教。<img src="/assets/u2uJkyp32X9LbdImwrML31mjbDe5dpQHCIUAMCTCqPoP_eHUv7Nps9sKNO1pMgXL6xJUWxlTdCrgH3e3wxVIaCGr-h4yMuk8Dg5dd5iAeGxN2PJjEw" width="20" height="20" /> <br />你们老板……当初是从哪里学来的呢 <img src="/assets/GN1_kO1NRzBZhVVzfohyoayBHDN9y8jroEerrTfnenTp3lfX8PSH6BARpWbSHEmKNH6RLqoRpyOZmexrTX_3h1BV4t7fugGjLj07vw7L7fokT_MtMg" width="20" height="20" /> <br />因为如果原来不是oracle的人的话，我仅仅知道国外这样的人有一些，国内的同时精通oracle+os + 开发 的人，很罕见的 。我只是听闻国内有oracle的人出去做这类产品去了，但具体名字不清楚，不知道是不是你们老板。 <br />这 个如果基于存储的复制方式是同步的,这是可以保证的.因为同步复制是复制IO,而且是主机端写IO的顺序技术复制的顺序,主要分成以下四步:主机端一个 IO下来,存储复制到远端,然后远端完成IO,最后返回通知主机IO完成. 但是存储不保证数据库在此时逻辑上是一致的,这是靠数据库本身的机制来完成的. 即此时源端数据库崩溃,如果可以通过数据库相应恢复手段来恢复的话,远端复制的存储也可以. <br />但如果是异步方式的话,问题就比较麻烦. 异步与同步的区别就是,异步主机IO下来后不需要等远端存储IO完成和确认,直接返回主机端IO完成. 这些IO暂时存放在源端存储缓存里,等累计到一定程度或满足给顶条件时,在传送到远端. 此时如何保证传递的IO顺序从而保证逻辑一致,就与具体的产品有比较大的关系了. 有的产品没有保证机制,直接用存放的顺序发送, 但在实际传送过程中没有保证,如由于线路等原因造成部分传送等. 有比较好的旧有时间戳和顺序号,而且还有逻辑分组,即主机端IO下来的时候是事务相关和逻辑分组的. 存储就将这一组IO逻辑分组,按写下的顺序标号, 这样在异步传送到远端后就可以根据逻辑分组和IO标号来完成IO. 类似具有事务的性质. <br />同步如果是从主机下来的IO直接复制，这样频繁的小IO将造成网络的大量问题，这对网络的要求太高了。 以前都是听人说同步是从 存储的cache 来的，拷贝的时候封锁cache不允许写…… <br />我觉得这个和同步I/O和异步I/O没有关系，对于存储级的复制，他们都有一个队列来保证I/O的次序，这是类似于ca/emc等厂商的这些存储级（varitas文件系统级）复制的一个共同点。至少我知道veritas声称的原理是这样的。 <br />如果不能保证I/O的次序，存储级复制没有任何意义。而且像ca这样的软件，他并不是实时改变多少就穿多少，我觉得他记录在磁盘头的tab应该隔多少时间加一次锁，然后新的插入写cache，所以如果这个时间源端off的话，cache中的数据应该是丢失的（磁盘坏）。 <br />软件级的复制也一样，你总有一个队列来处理ops/rac的事务顺序，这个队列有放在磁盘上用文件来排队的，也有直接在内存中排队的，这些也是关键的东西。当然像软件复制这样的软件可以通过重新分析日志的方式来弥补，如果磁盘没有坏的话。 <br />同步绝对就是那样，每个在SOURCE端写入的东西必须被远端的存储设备写入成功（不一定是写入磁盘）才返回主机写入成功，基本可以认为就是一个距离很远的RAID1。一致性的问题不用担心，但是带宽要求等等都是很高的。 <br />异步的方法，在之前很多是不能保证一致的，呵呵。最近据说多了很多能保证一致的方法，就知道HDS会吧所有写记录到本地一个日志卷，EMC和IBM的方法还没有弄的很清楚。 <br />看看我们的实际应用 <br />现在介绍我们数据库同步的成功案例，你们提到的问题都可以解决。 <br />现在我们的数据同步已经投入了实际运行，采用逐步增加表的方式。目前已经同步了149个表，其中包括详单表，统计基表等。最大的6000多万记录，有16个超过1000万记录，采用10分钟异步复制。主要有以下特点： <br />1、关键业务数据（排出了很多垃圾数据），数据量最小 <br />2、对生产机影响较小，目前一般只用到300M 空间 <br />3、目标端数据不可以修改，完全保证数据一致 <br />4、初始同步快捷、方便，不需要停止生产系统应用。影响小，只相当如一个select。 <br />5、管理方便、灵活：能够看到各表上次同步时间；上次同步后又有多少条新数据；上次各表同步耗费多长时间等。 <br />目前每天进行一次count(*) 检查，没有发现有问题。 <br />我们一前也试用过dsj和shareplex的产品，从名气上来说，应该还不错。具体不是我亲自试用的，但最后没有能够成功，我想与我们的系统复杂、数据库本身不是很稳定、要求太高有关。 <br />1、这是一个24小时运行的系统，停止应用程序来进行初始同步比较麻烦。 <br />2、需要在每天早晨从同步的数据中产生关键的数据和报表，要求不能耽误。 <br />3、要求管理维护简单、灵活：要求运行稳定，同步中断后能够简单快速处理完。 <br />现在我们用的oracle机制，加上第三方数据同步管理软件，只用了1个晚上就将主体数据同步好，一周就正式投入使用。然后逐步完善增加同步的表，目前已经同步了149张表，还对同步数据进行了分区处理等优化，从目前的近一个月的情况来看效果理想。 <br />经过一年半还多的时间试用了2家产品没有能够成功，用一周时间就解决了问题（主要报表实际上第二天就正式使用了），心里是多么的欣慰、兴奋和富有成就感。 <br />所以写了这么多东西。 <br />就是用了ORACLE物化视图技术+一个图形界面配置，还以为是啥东东哦。 <br />还有谁为建立报表机和容灾的数据同步而烦恼吗？ <br />oracle的功能确实很强大，这需要大家一起去挖掘，才会有基于oracle的更多更好的应用软件产生。 <br />samchj 兄，你是DSG的吧？海龟从ORACLE,IBM出来，而且专攻容灾的公司，我想不出第二家。你们的技术很牛，对底层很清楚，但让人担心对ORACLE后 续版本的支持。虽然所宣称的产品功能实现很吸引人，在测试中有不少问题，亟待完善。VP忙着改BUG，应该是没有什么时间来这灌水。 <br />关于BITI担心的存储同步问题，楼上的已经解释很清楚了。之所以存储厂商要求主节点、容灾节点更换成他们的存储设备，就是要解决I/O,CACHE的问题，从而保证同步端能够做到完全镜像。 <br />容灾端只有停掉同步，才能打开数据库，然后下一次再重做同步。而且他们还提供SNAPSHOT的功能，建立一个快照数据库，对于一个大数据库，需要的存储很可观。 <br />我个人认为，存储厂商的最大优势在于维护量少，有保障。DATA GUARD配置灵活，不依赖于底层，但需要人为监控。 <br />声明：我们这用的不是DATA GUARD <br />是一个第三方软件，目前报表机同步底层用的是 实例化视图。 <br />如果建立应用级的容灾，数据需要实时同步，估计需要用到同步复制技术了。目前还没有下决心做，担心性能问题。目前有过1个表的初步测试，还没有进行大量表的测试。 <br />对你的ppt提几个疑问： <br />1。传统同步软件方案为10年前的技术，比较落后。 <br />这个恐怕有些武断，相反对于数据库的复制我个人更看好如Quest的shareplex等产品。同样dataguard也使用类似技术，绝对不是如你所言是10年前的落后技术。 <br />2。传统同步软件方案，因其本身的缺陷，导致需要大量复杂的机制和操作来保证数据的一致，实施成本大。 <br />复 杂的机制不是最终客户需要考虑的，相反这些软件的实施成本是相应较小的（当然如果你的成本是指money的话，那自然是比物化视图高，不过仍然可以选用 DG），说起复杂的机制，即使是你使用的物化视图，也仍然有大量内部的控制是较复杂的，不过这些不需要实施者去考虑而已。 <br />3。采用硬件存储快照的方式，同步方式不灵活，将生产系统上所有的数据全部同步。（经过长时间运行和维护的生产系统往往大量的临时表和大量的垃圾数据，这些实际上是不需要同步的。 <br />通常基于存储的复制提供了卷一级的管理，完全可以通过配置不同的数据文件在不同的卷上来达到复制关键数据的目的。 <br />4。采用硬件存储快照的方式，耗费大量的存储设备，成本巨大。 <br />就我所知，至少veritas的vvr不需要太多额外的存储。 <br />5。华尔东城公司采用的独特方案，采用oracle的各种技术相结合，结合本公司独特的同步参数设置。通过本公司软件控制进行同步的管理。 <br />其实你这个ppt真是说的很含糊，用于单纯的sales宣传恐怕还可以，如果是用于技术交流实在是有些不痛不痒。 <br />6。华尔东城产品重要的益处，保证容灾数据完全一致，报表数据与10分钟前一致 。 <br />既然有10分钟的差距，为何仍然说容灾数据完全一致？如果说你们使用了物化视图的方案，那么就不可能在一个刷新期内（你们这儿的10分钟？）保证数据不丢失。除非还有业务log的分析软件作后备。 <br />7。华尔东城产品重要的益处，对主机性能影响小。 <br />其实物化视图的刷新对于主机并不是很小的影响，如果10分钟之内需要刷新大量的数据，可以明显的看到CPU的波峰，特别是oracle本身对于mvlog的处理还是有些问题的，所以不确定你们是否真的作过跟其它专业同步软件的主机性能影响的比较。 <br />8。本公司得益于oracle新技术的推出，加上本公司的努力，终于能够为数据同步提供完美的方案，这也是我们值得骄傲的一件事情。 <br />不否认你们确实作出了一个比较完备的同步解决方案，但是希望能够本着技术交流的想法在itpub讨论问题，而不是作单纯的商业宣传。我想很多人都希望知道你所指的oracle新技术是什么？不应该说就是物化视图吧。</p> <p class="read-more">Continue reading <a class="heading" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/e3-80-90-e8-bd-ac-e3-80-91-e6-95-b0-e6-8d-ae-e5-ba-93-e8-bf-9c-e7-a8-8b-e5-a4-8d-e5-88-b6-e5-92-8c-e5-bc-82-e5-9c-b0-e5-ae-b9-e7-81-be-e5-a4-a7-e8-ae-a8-e8-ae-ba.html" data-flip="title">【转】数据库远程复制和异地容灾 大讨论</a></p> </article> <article id="post-html5/2011/05/30/html5%e5%bc%80%e5%8f%91%e8%bf%9e%e8%bf%9e%e7%9c%8b%e9%97%ae%e9%a2%98" class="post mb6" role="article"> <header> <h1 class="post-title"> <a href="/html5/2011/05/30/html5-e5-bc-80-e5-8f-91-e8-bf-9e-e8-bf-9e-e7-9c-8b-e9-97-ae-e9-a2-98.html" data-flip="title"> html5开发连连看问题 </a> </h1> <p class="post-date heading"> <time datetime="2011-05-30T16:02:27+08:00">30 May 2011</time> in <span>Html5</span> on <span>Html5</span>, <span>Javascript web 前端</span>, <span>Web</span> </p> <div class="hr" style="padding-bottom:0"></div> </header> <p>1：引擎还是要改进一下：动画显示很慢，没有达到指定的fps的效果【不明白】， <br />在有的机器上怎么cpu在85%以上，fps越高，cpu越厉害，但是这里26 fps就这么慢了【不明白】 <br />2：音乐格式FF不支持mp3,但是ogg都支持。wav的播放很卡，safari还好。ie9不支持ogg，支持mp3和aac <br />3：对于坐标系统，要注意相对坐标高宽的变化，最好每次会只是都计算（要计算zoom比），因为如果canvas是百分比高宽的时候，浏览器的resize会导致绘制的图形压缩或扩大。 <br />4:ie9需要设置html5 doctype才能运行canvas，其它的浏览器即使你用的html4 doctype也可以。 <br />5:ie9不支持new Audio,但是document.createElement('audio');可以</p> <p class="read-more">Continue reading <a class="heading" href="/html5/2011/05/30/html5-e5-bc-80-e5-8f-91-e8-bf-9e-e8-bf-9e-e7-9c-8b-e9-97-ae-e9-a2-98.html" data-flip="title">html5开发连连看问题</a></p> </article> <article id="post-%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/%e3%80%90%e8%bd%ac%e3%80%91%e5%8f%8c%e6%9c%baracdataguard%e7%9a%84%e5%8c%ba%e5%88%ab" class="post mb6" role="article"> <header> <h1 class="post-title"> <a href="/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/e3-80-90-e8-bd-ac-e3-80-91-e5-8f-8c-e6-9c-baracdataguard-e7-9a-84-e5-8c-ba-e5-88-ab.html" data-flip="title"> 【转】双机/RAC/Dataguard的区别 </a> </h1> <p class="post-date heading"> <time datetime="2011-05-30T16:01:36+08:00">30 May 2011</time> in <span>分布式</span> / <span>数据库</span> on <span>数据库</span> </p> <div class="hr" style="padding-bottom:0"></div> </header> <p style="margin-top: 0pt;margin-bottom: 0pt;margin-left: 30pt"><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #888888;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none">2009-06-12 10:04</span></p> <table style="border-bottom: medium none;border-left: medium none;border-collapse: collapse;border-top: medium none;border-right: medium none"> <tbody> <tr style="height: 0px"> <td style="border-bottom: #aaa 1px dotted;border-left: #aaa 1px dotted;padding-bottom: 7px;padding-left: 7px;padding-right: 7px;vertical-align: top;border-top: #aaa 1px dotted;border-right: #aaa 1px dotted;padding-top: 7px"><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">Data Guard 是Oracle的远程复制技术，它有物理和逻辑之分，但是总的来说，它需要在异地有一套独立的系统，这是两套硬件配置可以不同的系统，但是这两套系统的软件结构保持一致，包括软件的版本，目录存储结构，以及数据的同步（其实也不是实时同步的），这两套系统之间只要网络是通的就可以了，是一种异地容灾的解决方案。而对于RAC，则是本地的高可用集群，每个节点用来分担不用或相同的应用，以解决运算效率低下，单节点故障这样的问题，它是几台硬件相同或不相同的服务器，加一个SAN（共享的存储区域）来构成的。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">Data Guard由两个多两个以上的独立的数据库构成，他们各自有各自的存储，Oracle负责他们之间的切换和数据同步</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">双机热备由两台计算机和一个共享存储设备构成，通过第三方软件（HA Rose等）实现切换，不需要做数据同步</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #0000ff;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">建议应用RAC+Dataguard ，RAC保证可用性，Dataguard在RAC组独立磁盘上和另外一台主机上，保证可靠性。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">双机就是人们所说的双机热备,数据库放在共享设备上，同一时刻只能有一台主机接管，另一台待用，这种方式只能保护实例，不能保护db，而且备机长期处于闲置，对资源是一种极大的浪费！</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">如果原本是双机，建议转换为RAC</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">规划好应用，DML操作从一个节点跑，查询操作从另一个节点跑，通常不需要太多调优就可以利用闲置的另外一台机器了</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">RAC服务器共用一套存储,同时提供服务,没有主备之分.宕一个其它的可以继续服务.</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">双机热备,共用一套存储,一个提供服务一个备份,主机宕了切换到备份服务器提供服务.</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">data guard 完全两套系统,存储是单独的,用日志同步.</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">RAC： 实例层冗余</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">DG ：数据库层冗余</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">热备：仅仅只是数据冗余</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">个人理解：</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">RAC ：实例冗余，而且还可以做到数据库的loadbalance。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">DG ：多份数据，所以能做到数据冗余，但是只有主节点提供服务。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">热备：与RAC最大的差异可能就是RAC有多个实例，一个数据库。而热备只是一个实例，一个数据库。所以做不了并发和loadbalance。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">Oracle RAC只是做Oracle的应用，rose，legato还可以做其它的</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #0000ff;font-size: 12pt;vertical-align: baseline;font-weight: bold;text-decoration: none">HA:</span><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">是High Availability 的首字母组合，翻译过来，可以叫做高可用，或高可用性，高可用（环境）。我觉得应该说HA是一个观念而不是一项或一系列具体技术，就象网格一样。作过系统方案就知道了，评价系统的性能当中就有一项高可用。广义的高可用涉及到系统的各个方面，简单来说，让系统不会中断 运行，就是高可用。包括软件的高可用，硬件的高可用，网络的高可用等等。具体实现的方案包括操作系统的集群，数据库的集群，硬件的冗余，网络的冗余等等。做HA方面的软件，有IBM的HACMP（很多常用AIX的人，常说的HA就指HACMP，乱啊）、SUN的Sun Cluster、HP的MC/SG等。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none"></span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">在 2000年以前，大家谈HA，大部分时候说的是操作系统一级的双机热备，主流产品当时有IBM HACMP4.1，HP的MC/SG啥版本忘了，sun的系统很多人不用VCS，用的是一个叫dataware的东西。现在很多人眼中的HA也还是这样。时至今日，HA包括的东西可就多了，先不说其他方面，单就数据库，单就Oracle，与HA相关的产品先后有：高级复制（AdvanceRepication)、OPS/RAC(Real Application Cluster）、数据卫士（Data Guard）、oracle流（Oracle Streams）、分区（Oracle Partition）这样数款产品。照这么说，RAC只是HA这个概念下的一个具体产品而已！目前为止，只有RAC和分区是Oracle要收取 licence的，其他的，只要给经验丰富的第三方实施方付一定的规划/设计及部署费用就可以了；当然，也可以自己照着文档依葫芦画瓢，但是这样弄出的环境是否能达到高可用就难说了。事实上，大部分人所说的HA，还是狭义上的HA，也就是OS一级的双机热备。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none"></span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #0000ff;font-size: 12pt;vertical-align: baseline;font-weight: bold;text-decoration: none">RAC:</span><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">是real application cluster的简称，它是在多个主机上运行一个数据库的技术，即是一个db多个instance。它的好处是 可以由多个性能较差的机器构建出一个整体性能很好的集群，并且实现了负载均衡，那么当一个节点出现故障时，其上的服务会自动转到另外的节点去执行，用户甚 至感觉不到什么。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none"></span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: bold;text-decoration: none">双机热备（HA）和RAC有啥区别呢?</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: bold;text-decoration: none"></span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">1、对于硬件来说，基本上一样，共享存储、光纤线（也有还用SCSI线的）、多台小型机（可以做多节点的相互热备，也可以做多节点的RAC）、光纤交换机（如果是用光纤卡的话）；但做RAC，在主机之间，最好使用高带宽网络交换机（虽然不用也可以做成）；</span><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #0000ff;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">因此硬件成本相差不大</span><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">2、软件呢，差别可不小。如果是双机热备，必须买操作系统级的双机管理软件；如果是RAC，目前还是建议购买双机管理软件（尽管10g的crs+asm可以摆脱双机软件了，但ASM目前实在太难伺候了），当然还得买RAC license。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">3、日常维护。RAC要求的技术含量更高，也应该更勤快。</span><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #0000ff;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">最关键的是得买oracle服务，否则遇到有些问题（bug），你就比单机还不高可用了</span><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">4、优缺点。这个，看看RAC的官方论述吧。如果能用好，确实是很有好处的。目前我们的40多个客户的使用情况来看，RAC确实大大降低了他们的downtime，另一方面可以说就是提高了生产力咯。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none"></span> <br /><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #0000ff;font-size: 12pt;vertical-align: baseline;font-weight: bold;text-decoration: none">Dataguard:</span><span style="background-color: transparent;font-style: normal;font-family: tahoma;color: #666666;font-size: 12pt;vertical-align: baseline;font-weight: normal;text-decoration: none">一般是出于容灾的目的。是主数据库的备用库（standby 库）通过自动传送和接受archivelog，并且在dataguard库自动apply 这些log，从而达到和主数据库同步的目的，可能dataguard 库是建立的异地的，当主库所在的区域出现了致命性的灾难时(火灾、地震等)，主库没法修复时，这时可以切换dataguard 为主库的模式，对外提供服务，而它的数据基本是当前最新的。目前可能大家对于 dataguard 库的使用已经拓展出了其他更多的用途，比如备份，跑报表等等</span></td> </tr> </tbody> </table> <p><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"></span></p> <p class="read-more">Continue reading <a class="heading" href="/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/e3-80-90-e8-bd-ac-e3-80-91-e5-8f-8c-e6-9c-baracdataguard-e7-9a-84-e5-8c-ba-e5-88-ab.html" data-flip="title">【转】双机/RAC/Dataguard的区别</a></p> </article> <article id="post-%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/%e3%80%90%e8%bd%ac%e3%80%91%e5%b7%a5%e5%95%86%e9%93%b6%e8%a1%8c%e4%b8%8a%e6%b5%b7%e6%95%b0%e6%8d%ae%e4%b8%ad%e5%bf%83%e5%a4%87%e4%bb%bd%e6%96%b9%e6%a1%88%e8%a7%a3%e6%9e%90" class="post mb6" role="article"> <header> <h1 class="post-title"> <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/e3-80-90-e8-bd-ac-e3-80-91-e5-b7-a5-e5-95-86-e9-93-b6-e8-a1-8c-e4-b8-8a-e6-b5-b7-e6-95-b0-e6-8d-ae-e4-b8-ad-e5-bf-83-e5-a4-87-e4-bb-bd-e6-96-b9-e6-a1-88-e8-a7-a3-e6-9e-90.html" data-flip="title"> 【转】工商银行上海数据中心备份方案解析 </a> </h1> <p class="post-date heading"> <time datetime="2011-05-30T16:00:41+08:00">30 May 2011</time> in <span>数据库</span> on <span>数据库</span> </p> <div class="hr" style="padding-bottom:0"></div> </header> <p><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: bold;text-decoration: none">一、中国工商银行上海数据中心数据备份和恢复的需求</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> </span><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: bold;text-decoration: none">1.1. 用户的需求</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 中国工商银行上海数据中心(以下简称上海数据中心)，每天需要对 VSE/ESA 生产主机 和 OS/390 生产系统上的生产和系统数据进行备份，包括批处理前和批处理后的数据备份。上海数据中心每天需要从 8 个 VSE/ESA 系统和 8 个 OS/390 系统上的数百个 3390-3 型磁盘卷上备份大量 VSAM 文件(业务数据) 和备份磁盘卷的整卷数据。现在，每个VSE/ESA 生产系统的每天的数据备份量达 200 盘 3490E 磁带，其中有 60 盘左右为对磁盘卷的备份。为了不间断业务运行，缩短批处理时间，不影响生产运行。上海数据中心对数据备份操作的要求是：</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 确保数据安全性和完整性。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 缩短备份时间，减少由于备份对业务的中断。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 如果需要进行数据恢复时，恢复操作要准确、迅速，时间短。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 备份和恢复操作要简捷，便于操作员的日常使用。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 为了将数据备份时间缩短到最小，上海数据中心希望利用磁盘快速复制技术，或者虚 拟磁带系统来快速完成备份操作。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 上海数据中心最终备份的的数据是 VSAM 文件。单个文件的数据量不大，但是文件数量众多。对这种类型数据的备份和恢复，虚拟磁带系统(VTS)技术将是最好的解决方案。上海数据中心最终利用 StorageTek 公司 的、运行在 OS/390 操作系统上的 HSC 和 VTCS 软件，配合以运行在 VSE/ESA 操 作系统上的、MT Consultant 公司的 LMS/VSE 软件来完成这些备份任务的。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> </span><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: bold;text-decoration: none">二、方案介绍</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 由于上海数据中心需要备份的数据量庞大，将来的备份磁带数量一定很多。因此，上海数据中心应该采用自动磁带库来管理备份磁带。并采用物理磁带及 和虚拟磁带机相结合的数据备份和恢复技术，来提高数据备份的效率和存储空间的利用率。 9490 磁带机与 3490E 磁带机完全兼容，采用 IDRC 压缩和 3490E E-cart，单盘磁带的容量为 2.4 GB。由于上海数据中心的磁盘卷大多数为 3390-3 型，容量为2.89 GB，将占用 2 盘 3490E E-cart 磁带。上海中心采用 9490 磁带机 EE-tape 功能，一盘磁带的容量可以高达 4.8 GB (压缩后)。对于 OS/390 磁盘卷整卷的备份，上海数据中心采用 StorageTek 9310 自动磁带库和 9840高性能、大容量磁带机。如果配合 StorageTek exHPDM 软件，可以将数个磁盘卷同时 备份到一盘 9840 磁带上。将能充分发挥 9840 磁带机的性能和充分利用 9840 磁带的容量。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 根据工商银行上海数据中心对数据备份和恢复的要求，采用 StorageTek 公司 9310 自动磁带库加 StorageTek 公司的 VSM(虚拟存储系统)的综合磁带解决方案。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> VSM 主要处理大量小文件的备份和恢复，如 VSAM 文件、CICS 日志、数据库增量 备份等。而对大型文件备份和恢复，则直接使用 9310 自动磁带库中磁带驱动器，如对磁盘卷的整卷备份、数据库的全备份等操作。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 本方案涉及的硬件和软件产品</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 1 1套 StorageTek 9310 自动磁带库系统</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 2. 1套 StorageTek VSM 虚拟存储系统</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 3. 8 套 HSC (主机软件部件) 软件</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 4. 1套 VTCS (虚拟磁带控制软件)</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 5. 8 套 LMS/VSE 软件及 8 套 5193 磁带库管理网关</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 6. 磁带管理软件</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 在 OS/390 系统上采用 CA 公司的 CA-1/TMS 磁带管理软件。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 在 VSE/ESA 系统上采用 CA 公司的 DYNAM/T 磁带管理软件。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> </span><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: bold;text-decoration: none">2.4. 磁带库和 VSM 系统硬件连接方案</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 若要实现虚拟磁带卷的迁移和回迁，VSM 至少需要 9310 磁带库中的 2 台 9840 物 理磁带驱动器与其相连接。如果迁移和回迁的工作量比较大，则需要更多的磁带机驱动器。由于 VSM 主要用于处理大量小文件的备份和恢复。而对大型文件的备份和恢复仍需要直接使用 9310 自动磁带库中 9840 磁带驱动器。因此 9310 自动磁带库必须要有 直接(或通过 ESCON 通道转接器)连接到 OS/390 主机上的磁带机驱动器。如果主机上同时提交了多个大型文件的备份或恢复作业，则需要有多个磁带机驱动器。否则，将会有作业因没有可用的磁带驱动器而等待。 如果将 9310 中的多个磁带驱动器给 VSM 专用，再将另一些磁带驱动器给主机专用，则需要更多的磁带驱动器。直连的优点是，日常操作比较简便。但是，这样做投资 比较大，而且磁带驱动器不能得到充分的利用。这样如何充分、有效地利用磁带库 中磁带驱动器，则是需要解决的问题。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 上海中心每个VSE系统每天的数据备份量平均为 200 盘 3490E 磁带。不含磁盘卷的备份磁带。按照实际存储在每盘磁带上的数据量平均为 100 MB，那么 8 个 VSE 系统每天的备份数据总量为 160 GB。如果这些备份数据驻留在 VSM 的时间为 1 天，那么VSM的容量至少为 160GB。如果这些备份数据的保留时间为 30 天，则总的数据容量为 9.6 TB。 自动磁带库中将 需要至少 120 盘 9840 磁带来保留这些备份磁带。如果将每天每个 VSE 系统的备份数 据迁移到一盘 3490E 磁带中， 30 天则需要 240 盘 3490 磁带。 如果 OS/390 系统的备份的数据量与 VSE/ESA 系统的相近，则对 VSM 容量的要求将 与以上分析大体相近。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> </span><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: bold;text-decoration: none">三、方案技术要点</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 虚拟磁带存储管理是对磁带和自动磁带库解决方案的重大革新。它是自从磁带库出现以来，第一个为批量处理而发明的新技术。虚拟磁带使现有的技术能够得到充分地利用。虚拟磁带技术将批处理中的磁带操作变得更加有效，使高密度介质、高性能磁带机和高速通道得以充分利用。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> VSM 虚拟磁带系统所带来的最大利益是极大地提高了批处理的性能，这是用户可以直接感受到的虚拟磁带技术所带来的影响。其带来的间接利益还有很多，包括：充分利用现有的磁带机和磁带资源，解决磁带驱动器紧张的问题，简化了磁带管理。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"> 对于小型批处理文件的备份，装带和卸带时间占整个磁带操作时间(占用磁带机驱动器的时间)的很大一部分。利用虚拟磁带技术，将没有装带和卸带的 时间，所以整个磁带操作时间将显著降低。 这将带来两大好处：第一，批处理作业将运行地更快，从而缩小批处理窗口;第二， 虚拟磁带机驱动器的利用率更高，减少作业等待驱动器的时间，降低了对驱动器数 量的需求。再加上虚拟磁带系统提供的虚拟磁带驱动器数量很多，使系统可以同时 处理大量批处理备份作业，减少作业的等待时间。如果需要从仍驻留在 VSM 中 虚拟磁带中恢复数据，由于该虚拟磁带卷仍然驻留在缓存中，VSM 将会直接将它恢复到主机磁盘上。整个过程不需要装带/卸带操作，缩短了恢复的时间，也缩短了批处理的时间。用户可以定义虚拟磁带卷驻留的时间。</span> <br /><span style="background-color: transparent;font-style: normal;font-family: arial;color: #000000;font-size: 11pt;vertical-align: baseline;font-weight: normal;text-decoration: none"></span></p> <p class="read-more">Continue reading <a class="heading" href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/e3-80-90-e8-bd-ac-e3-80-91-e5-b7-a5-e5-95-86-e9-93-b6-e8-a1-8c-e4-b8-8a-e6-b5-b7-e6-95-b0-e6-8d-ae-e4-b8-ad-e5-bf-83-e5-a4-87-e4-bb-bd-e6-96-b9-e6-a1-88-e8-a7-a3-e6-9e-90.html" data-flip="title">【转】工商银行上海数据中心备份方案解析</a></p> </article> <article id="post-%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/%e3%80%90%e8%bd%ac%e3%80%91%e4%b8%bb%e6%b5%81%e6%95%b0%e6%8d%ae%e5%ba%93%e9%9b%86%e7%be%a4%e6%8a%80%e6%9c%af%e6%b7%b1%e5%85%a5%e6%8e%a2%e8%ae%a8" class="post mb6" role="article"> <header> <h1 class="post-title"> <a href="/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/e3-80-90-e8-bd-ac-e3-80-91-e4-b8-bb-e6-b5-81-e6-95-b0-e6-8d-ae-e5-ba-93-e9-9b-86-e7-be-a4-e6-8a-80-e6-9c-af-e6-b7-b1-e5-85-a5-e6-8e-a2-e8-ae-a8.html" data-flip="title"> 【转】主流数据库集群技术深入探讨 </a> </h1> <p class="post-date heading"> <time datetime="2011-05-30T15:59:58+08:00">30 May 2011</time> in <span>分布式</span> / <span>数据库</span> on <span>Web</span>, <span>集群</span> </p> <div class="hr" style="padding-bottom:0"></div> </header> <p>用来保存计算最终结果的数据库是整个信息系统的重要组成部分，技术也相对成熟。然而，对于所有数据库而言， 除了记录正确的处理结果之外，也面临着一些挑战：如何提高处理速度，数据可用性、数据安全性和数据集可扩性。将多个数据库联在一起组成数据库集群来达到上 述目标应该说是一个很自然的想法。 <br /> 集群（Cluster）技术是使用特定的连接方式，将价格相对较低的硬件设备结合起来，同时也能提供高性能相当的任务处理能力。 <br /> 本文试图对当前主要的数据库集群用到的具体技术和市场上的主流产品进行分析并作点评，从而为读者提供一个数据库集群的评价参考。 <br /> 下面讨论的数据库集群技术分属两类体系：基于数据库引擎的集群技术和基于数据库网关（中间件）的集群技术。 <br /><img src="/assets/s4J3SSQHKzTnIcsBkW8tykp8PbmDJ20nfVIPXs4ZSprEKPyFgO_w34oyt5IqPIzsXZLpYERIOHzNuwP5HZR_8H9IggjepYJyuchG0x3NOmBF084dKw" width="410" height="276" /> <br /> 基于数据库引擎的集群技术（共享磁盘或非共享磁盘） <br /><img src="/assets/CG2fXX7UMcjW2sxhmcBvj0EZU1ROAEXcRsz8Tas_AP4BUKMFnGG0UHnklORyORaIXi3IoCej_PPlt7W7iWcP2IF-llJEcMs8xRzIY_Bi8Kfg8TzZ0Q" width="387" height="280" /> <br /> 基于数据库网关（中间件）的集群技术（不共享磁盘） <br />关键技术 <br /> 在复杂的数据库集群技术之间做比较，其实就是比较它所包含的各项子技术性能和它们之间的协调运作能力，下面的文字将介绍数据库集群最需要得到重视的核心技术，同时也关注到了一些技术细节。 <br /> 提高处理速度的四种办法 <br /> 提高磁盘速度：主要思想是提高磁盘的并发度。尽管实现方法各不相同，但是它们最后的目的都是提供一个逻辑数据库的存储映象。 <br /> 【点评】系统为了提高磁盘访问速度，建立一个虚拟的涵盖所有数据“大”数据库，而不用去考虑数据的实际物理磁盘存放位置。 <br /> 分散数据的存放：利用多个物理服务器来存放数据集的不同部分，使得不同的服务器进行并行计算成为可能。 <br /> ORACLE RAC是共享磁盘的体系结构，用户只需简单地增加一个服务器节点，RAC就能自动地将这节点加入到它的集群服务中去，RAC会自动地将数据分配到这节点 上，并且会将接下来的数据库访问自动分布到合适的物理服务器上，而不用修改应用程序；UDB是非共享磁盘的体系结构，需要手工修改数据分区，MSCS和 ASE也是同样情况。ICX是一种基于中间件的数据库集群技术，对客户端和数据库服务器都是透明的。可以用来集群几个数据库集群。 <br /> 【点评】系统通过化整为零的策略，将数据表格分散到多个服务器或者每个服务器分管几个内容不同的表格，这样做的目的在于通过多服务器间并行运算以提高访问速度。 <br /> 对称多处理器系统： <br /> 利用多处理机硬件技术来提高数据库的处理速度。 <br /> 所有基于数据库引擎的集群都支持这个技术。 <br /> 【点评】将多CPU处理器进行合理调度，来同时处理不同的访问要求，但这种技术在数据库上的应用的实际收益是很有限的。 <br /> 交易处理负载均衡：在保持数据集内容同步的前提下，将只读操作分布到多个独立的服务器上运行。因为绝大 多数的数据库操作是浏览和查询，如果我们能拥有多个内容同步的数据库服务器，交易负载均衡就具有最大的潜力（可以远远大于上面叙述的最多达四个处理器的对 称多处理器系统）来提高数据库的处理速度，同时会具有非常高的数据可用性。 <br /> 所有基于数据库引擎的集群系统都只支持一个逻辑数据库映象和一个逻辑或物理的备份。这个备份的主要目的 是预防数据灾难。因此，备份里的数据只能通过复制机制来更新，应用程序是不能直接更新它的。利用备份数据进行交易负载均衡只适用于一些非常有限的应用，例 如报表统计、数据挖掘以及其它非关键业务的应用。 <br /> 【点评】负载平衡算是一项“老”技术了。但将性能提高到最大也是集群设计所追求的终极目标。传统意义上，利用备份数据进行交易负载均衡只适用于一些非常有限的应用。 <br /> 上述所有技术在实际部署系统的时候可以混合使用以达到最佳效果。 <br /> 提高可用性的四种方法 <br /> 硬件级冗余：让多处理机同时执行同样的任务用以屏蔽瞬时和永久的硬件错误。有两种实现方法：构造特殊的冗余处理机和使用多个独立的数据库服务器。 <br /> 基于数据库的集群系统都是用多个独立的数据库服务器来实现一个逻辑数据库，在任意瞬间，每台处理器运行的都是不同的任务。这种系统可以屏蔽单个或多个服务器的损坏，但是因为没有处理的冗余度，每次恢复的时间比较长。 <br /> 【点评】传统意义上，硬件越贵，性能越高，但往往事与愿违。想通过追加和升级硬件设备来改善硬件级的冗余，要进行详细的需求分析和论证。 <br /> 通讯链路级冗余：冗余的通讯链路可以屏蔽瞬时和永久的通讯链路级的错误。 <br /> 基于数据库引擎的集群系统有两种结构：共享磁盘和独立磁盘。RAC, MSCS 可以认为是共享磁盘的集群系统。UDB和ASE 是独立磁盘的集群系统。共享磁盘集群系统的通讯的冗余度最小。 <br /> 【点评】通讯链路级的冗余具有容错功能。 <br /> 软件级冗余：由于现代操作系统和数据库引擎的高度并发性，由竞争条件、死锁、以及时间相关引发的错误占 据了非正常停机服务的绝大多数原因。采用多个冗余的运行数据库进程能屏蔽瞬时和永久的软件错误。基于数据库引擎的集群系统都用多个处理器来实现一个逻辑数 据库，它们只能提供部分软件冗余，因为每一瞬间每个处理器执行的都是不同的任务。 <br /> 【点评】改善软件设计来提高冗余性能和屏蔽软件级错误是每个技术开发商的梦想。传统的集群系统只能提供部分软件冗余。 <br /> 数据冗余： <br /> 1. 被动更新数据集：所有目前的数据复制技术(同步或异步)，例如磁盘镜像、数据库文件复制以及数据库厂商自带的数据库备份工具都只能产生被动复制数据集。它一般只用于灾难恢复。 <br /> 【点评】大多数应用都是采用被动更新数据集的方法。这种方法容灾能力差，资源占用多，已面临淘汰和革新。 <br /> 2. 主动更新数据集：这种数据集需要一台或多台备份数据库服务器来管理，它可用于报表生成，数据挖掘，灾难恢复甚至低质量负载均衡。分同步和异步两种。 <br /> 异步主动复制数据集：先把事务处理交给主服务器来完成，然后事务处理再被串行地交给备份服务器以执行同样操作来保证数据一致性。所有的商用数据库都支持异步主动复制技术。 <br /> 同步主动复制数据集：要求所有并发事务处理在所有数据库服务器上同时完成。直接好处就是解决了队列管理 问题，同时通过负载均衡实现更高性能和可用性。RAC, UDB, MSCS 和 ASE是用完全串行化并结合两阶段提交协议来实现的，设计目标就是为了获得一份可用于快速灾难恢复的数据集。 <br /> 【点评】主动更新数据集是目前比较先进的数据冗余方法。专业人员还可以进行更底层的技术细节比较。底层技术的差异直接影响着一些重要指标。 <br /> 提高安全和数据集可扩性的技术 <br /> 在提高数据库安全性和数据集可扩性这两方面，可以创新的空间是很小的。数据库最常见的安全办法是口令保 护，要么是分布式的，要么是集中式的。在数据库前面增加防火墙会增加额外的延迟，因此，尽管许多安全侵犯事件是来自于公司内部，但是数据库防火墙还是很少 被采用。如果数据库集群技术是基于中间件技术实现的，就有可能在不增加额外延迟的情况下，在数据经过的路径上实现防火墙功能。数据库数据集的可扩性只能通 过将数据分布到多个独立的物理服务器上来实现。 <br />主流产品 <br /> 在数据库集群产品方面，其中主要包括基于数据库引擎的集群技术的Oracle RAC、Microsoft MSCS、IBM DB2 UDB、Sybase ASE，以及基于数据库网关（中间件）的集群技术的ICX-UDS等产品。 <br /> Oracle RAC <br /> Oracle RAC 支持 Oracle 数据库在集群上运行的所有类型的主流商业应用程序。这包括流行的封装产品，如 SAP、PeopleSoft 和 Oracle E-Business Suite 等，以及自主研发的应用程序，其中包括 OLTP 和 DSS，以及 Oracle 有效支持混合 OLTP/DSS 环境的独有能力。Oracle 是唯一提供具备这一功能的开放系统数据库的厂商。 Oracle RAC 运行于集群之上，为 Oracle 数据库提供了最高级别的可用性、可伸缩性和低成本计算能力。如果集群内的一个节点发生故障，Oracle 将可以继续在其余的节点上运行。如果需要更高的处理能力，新的节点可轻松添加至集群。为了保持低成本，即使最高端的系统也可以从采用标准化商用组件的小型 低成本集群开始逐步构建而成。 <br /> Oracle 的主要创新是一项称为高速缓存合并的技术，它最初是针对 Oracle9i 真正应用集群开发的。高速缓存合并使得集群中的节点可以通过高速集群互联高效地同步其内存高速缓存，从而最大限度地低降低磁盘 I/O。高速缓存最重要的优势在于它能够使集群中所有节点的磁盘共享对所有数据的访问。数据无需在节点间进行分区。Oracle RAC 支持企业网格。Oracle RAC 的高速缓存合并技术提供了最高等级的可用性和可伸缩性。Oracle RAC能显著降低了运营成本，增强了灵活性，从而赋予了系统更卓越的适应性、前瞻性和灵活性。动态提供节点、存储器、CPU 和内存可以在实现所需服务级别的同时，通过提高的利用率不断降低成本。 <br /> Oracle RAC采用了“sharing everything”的实现模式,通过CPU共享和存储设备共享来实现多节点之间的无缝集群，用户提交的每一项任务被自动分配给集群中的多台机器执行， 用户不必通过冗余的硬件来满足高可靠性要求。另一方面，RAC可以实现CPU的共享，即使普通服务器组成的集群也能实现过去只有大型主机才能提供的高性 能。 <br /> Microsoft MSCS <br /> 数年以来，Microsoft一直致力于对自身服务器解决方案的伸缩能力、可用性与可靠性进行扩展。最 初代号为Wolfpack且先后被称为Microsoft集群服务器与Microsoft集群服务的MSCS是Microsoft在NT集群技术领域中的 首次重拳出击，它是公认的最佳Microsoft集群解决方案。在MSCS群集中，MSCS软件最多可以同四台运行在高速网络上的物理计算机建立连接。通 常情况下，群集中的计算机能够按照“活动--活动”方式共享相同的存储子系统与功能，这意味着所有集群计算机（节点）均可主动通过共享负载的方式协同完成 工作，并在某个节点出现故障时分担它的工作。MSCS的主要用途是通过自身提供的容错能力提高应用程序可用性。容错能力是指将相关处理过程从某个节点上的 故障应用程序移植到集群中其它健康节点上的集群功能。当故障应用程序得到恢复后，集群应当能够对原先的集群节点实现“故障返回”。MSCS能够在不丢失任 何与故障应用程序相关数据的前提下对集群上所运行的应用程序进行故障恢复与故障返回管理，并且能够在故障恢复过程中维护用户及应用程序状态。这种类型的集 群功能被称作有状态集群功能。MSCS同时还允许用户在应用程序升级过程中继续进行工作。您可以采取滚动升级方式（例如每次在一个集群节点上升级应用程序 并确保其它节点上的应用程序继续处于可用状态）而不必在升级过程中停止使用应用程序。 <br /> SQL Server 2005是微软的下一代数据管理和分析解决方案，给企业级应用数据和分析程序带来更好的安全性、稳定性和可靠性，更易于创建、部署和管理。它凭借针对故障 转移群集机制的支持能力，得以增强的多实例支持能力以及分析服务对象与数据备份及恢复能力，分析服务的可用性得到了提高。它提供了诸如表分区、快照隔离、 64位支持等方面的高级可伸缩性功能，使用户能轻松构建和部署关键应用。表和索引的分区功能显著增强了对大型数据库的查询性能。 <br /><img src="/assets/nThYgjXPVo64LTKnu9uE-l_9v1aMy87gu6KrTuPQgiGaCNaggoRJCLimHNXIYXTJCDDJpWRUtOEPLSj13gI6faF_S_RC-oL4Y92_PX4ID1ualxzWgQ" width="350" height="283" /> <br /> 利用Windows 2000 MSCS实现的4节点集群 <br />性能指标 <br /> 这部分将介绍集群系统的细节技术指标。在做系统规划时，用户就可去掉一些应用中不太重要的指标，或赋予这些指标以不同的权重，从而进行专业的技术性能比较，选择最适合自己的数据库集群系统。 <br /> 处理速度 <br /> 磁盘技术：所有集群系统都能很好地应用磁盘技术，但是由于DM，FM会对磁盘系统带来传输速度的负面影响，因此这方面它们相对欠缺。 <br /> 数据分割：所有基于数据库引擎的集群系统都有很好数据分割能力。 <br /> SMP：所有基于数据库引擎的集群系统的SMP性能指标都比较接近。 <br /> 负载均衡：一般的数据库引擎的集群系统由于使用了备份的数据集，因此只能支持有限的负载均衡。这一指标不同产品之间有差异。 <br /> 数据可用性 <br /> 处理器和软件冗余：只有部分集群系统支持该功能。 <br /> 通讯链路冗余：一般来说，共享磁盘的集群系统通讯链路冗余指标较低，独立磁盘的集群系统指标较高。 <br /> 数据冗余： <br /> 主动异步复制：除了磁盘和文件镜像外，其他集群系统支持该功能。 <br /> 主动同步复制：所有集群系统支持该功能，细节指标略有不同。 <br /> 被动异步复制：所有集群系统该性能指标都比较接近。 <br /> 被动同步更新：所有集群系统该性能指标都比较接近。 <br /> 通过广域网的复制技术： <br /> 远程主动异步复制：所有的集群系统都支持这种复制技术，只不过对队列的管理能力有所不同。DM，FM和RAID的此性能相对较低。RAID不支持远程复制功能。 <br /> 远程主动同步复制：ICX在这方面做的比较好。 <br /> 远程被动异步复制：DM 和 FM支持这种类型的复制，因为DM和FM对集群是透明的，是在集群系统的下一层工作的，所有的集群系统都可以利用它们提供的功能。 <br /> 远程被动同步复制：DM和FM支持这种类型的复制，因为这种复制方式只在距离很近的时候才能使用（使用双模光纤，半径五英里）。同样地，因为DM和FM对集群是透明的, 所有的集群系统都可以利用它们提供的功能, 如果部署的话，所有的集群系统都是类似的。 <br /> 安全性 <br /> 口令：这是所有集群系统的基本性能。分布式或集中式的口令保护基本上保证了数据的安全。 <br /> 数据库防火墙：大多数数据库集群系统得数据库防火墙很少被采用，而ICX则采用在数据经过的路径上实现防火墙功能。 <br /> 数据集的可扩性 <br /> 数据分区：所有基于数据库引擎的集群系统都具备数据分区以保证数据集的可扩展。 <br /> 数据分区的可用性：所有集群系统该性能指标比较接近。 <br /> 集群管理 <br /> 共享磁盘的集群系统，比如RAC、MSCS，它们的管理比较方便，其中RAC的服务更多。但是，由于此 种系统中的每一单独的服务器需要特殊处理，和独立磁盘的集群系统比较，就容易管理多了（虽然进行初始化和修改配置的时候也不那么容易）,但它们都要求应用 程序对集群不透明，而且配置，修改也比较麻烦。 <br /> 独立磁盘的集群系统象 UDB、ASE此性能相对稍低，因为用的都是非共享磁盘，所以管理相对繁琐。 <br /> ICX在易管理性（初始配置和将来的修改）方面和独立磁盘集群系统的性能相当，但是在对底层数据管理复杂性方面做得比较好。在对数据库引擎和数据进行底层修复的时候任务需要直接到每台数据库处理器上去做。 <br /> 那些磁盘工具，即DM、FM和RAID，它们对集群是透明的。管理相对简单得多。 <br /> 应用透明度 <br /> 因为在错误回复和分区方面对应用程序不透明以及它们对应用程序都有些特殊的要求，基于数据库引擎的RAC、MSCS、UDB、ASE和ICX在这方面都有待提高的地方。而DM、FM和RAID它们对应用程序可以说是完全透明的。 <br />IBM DB2 UDB <br /> DB2 UDB大量自动或自我管理功能可使管理员能够节省更多时间来集中精力考虑驱动业务价值的问题，甚至可以消除较小的实施项目对专职管理员的需求。 <br /> UDB的优势体现在DB2的开放无界:支持Unix, Linux 以及Windows等主流操作系统；支持各种开发语言和访问接口；同时具有良好的数据安全性和稳定性。DB2 V8.2的高可用性灾备技术，可在极短时间内使关键应用得到恢复。利用DB2数据分区部件(DPF)实现横向扩展，可以支持多达1000台服务器组成的庞 大数据库群集，为构建企业级数据仓库提供坚实的技术基础。利用DB2的数据分区部件以及DB2信息集成器(DB2 II)技术，数据库操作可综合利用网格中的每台服务器的运算能力，实现真正意义上的网格运算。 <br /> UDB V8.2应用更多的创新技术，Design Advisor可以帮助 DBA 制定全面的数据库设计决策，包括集成复杂的功能划分、物化查询表，大大缩短部署时间。自动生成统计信息概要代表了来自 IBM LEO研发项目的首次部署。自主对象维护特性可自动执行基于策略的管理和维护功能，如表重构、统计信息收集和数据库备份。高可用性灾难恢复和客户机重路由 特性实现了具备随选能力的企业所需的24*7信息可用性和恢复力。此外，DB2 UDB 提供与 Java/Eclipse 和 Microsoft .NET IDE的深入集成或插件。 <br /><img src="/assets/4_46M16yfayXrL8B0V8rkw2WgnU2gQ7tfja1hyR4sZz7REFOklrLS59RrpHeEIAgTu8a-Ya-JxENhPnbgtQDyPPfiqKwy1nHUg_Mbjm3mJh27Fz32g" width="339" height="243" /> <br /> DB2 UDB结构拓扑图 <br /> SYBASE ASE <br /> ASE性能的提高是建立在虚拟服务器架构上的，这是 Sybase 独有的体系结构。当前的ASE版本是ASE15。与操作系统和相关软件保持独立让ASE15可以更智能化地进行系统自我调优。VSA只需要很少的内存资源 和内部交换开销，所以ASE15可以管理大量的联机用户。能够使ASE提高性能并控制成本的最主要原因是它采用了专利技术的、自调整的优化器和查询引擎。 它可以智能地调整复杂的查询操作并忽略那些未包含相关信息的分区上的数据。ASE15还通过一系列用来管理和诊断数据库服务器的新特性来降低运营成本。 <br /> ASE15 拥有高可靠性和极低的运行风险。个人数据的安全性是ASE特别关注的领域，使用了一种无需修改应用的独特加密系统。当应用和安全软件进行连接时将降低实施 成本并避免产生新的安全漏洞。ASE15 还通过一种简单、直接和可编程的脚本语言来方便进行加密和解密。在解决意外停机问题时，ASE15 在其已证实的可靠性和高系统利用率的基础上，增加了许多显著的功能来增强系统的可用性和灾难恢复过程。新的存储引擎支持四种数据分区方式，在不同的物理设 备上进行不同的分区操作。能帮助数据库管理员迅速地建立冗余灾难恢复节点并在异构的数据平台上同步数据库。 <br /> ASE15系统新的查询和存储引擎被设计用于支持下一代网格计算和集群技术。它结合了充分利用数据分区 技术的查询处理机制和适用于解决集群问题的优化器技术。同时ASE15为事件驱动的企业提供了一个绝好的数据库平台。与web services 和 XML的架构将减少系统内部的相互依赖性，并为应用开发提供更大的灵活性。 <br /> ICX-UDS <br /> ICX-UDS不受基于数据库引擎的集群技术限制，可以支持不同的数据库。 <br /> 它类似通常的代理服务器。把ICX放置在关键的网络路径上，监听数据库系统流量。ICX网关将自动过滤 出无状态的查询访问，并将负载均衡到所有服务器上。在这里，网关就象一个在线“编译器”，它将所有对数据库的更新操作发送到所有数据库上执行，而将无状态 的查询操作只发送到其中某一数据库服务器上。 <br /> 对于统计报表和数据挖掘类应用，可以通过复制和只读去获得更快的处理速度。还能指定更多的只读来负载均衡。ICX 网关的容错可以通过备份网关来达到。加载一个非同步的数据库可以造出不影响主服务机群的近于实时的数据源。 <br /><img src="/assets/PKEurdOxK6PVyrQwwdoJMCzQbWGoRlhVR9tvHLT6iVj8vOraZ_WZlmd2-mwkggdCPeZP-bQb1wGM_s9rozosJ-kKAxhxCQK7acqYgDypKJ336CgEyQ" width="402" height="321" /> <br /> ICX 网关和负载均衡器配置示意图 <br />应用点评 <br /> Oracle RAC和Oracle数据库提供的特定新管理性增强功能实现了企业网格。各种规模的企业都可以采用Oracle RAC来支持各类应用程序。 <br /> 企业网格采用大型标准化商用组件配置：处理器、网络和存储器。利用Oracle RAC的高速缓存合并技术，Oracle数据库实现了最高可用性和可伸缩性。现在，利用Oracle数据库和Oracle RAC将大幅降低了运行成本，进一步增强了灵活性，其动态提供节点、存储器、CPU和内存的特性可以更轻松、高效地保持服务级别，而通过提高的利用率又进 一步降低了成本。企业网格是未来的数据中心，使企业具备更高的适应能力、前瞻性和敏捷性。 <br /> 集群技术随着服务器硬件系统与网络操作系统的发展将会在可用性、高可靠性、系统冗余等方面逐步提高。我们汇集了市场上的主流产品，并从分析性能指标的角度出发，对产品进行了简要评价。 <br /> Sybase ASE是一个深受用户欢迎的高性能数据库，它具有一个开放的、可扩展的体系结构，易于使用的事务处理系统，以及低廉的维护成本。 <br /> ASE可支持传统的、关键任务的OLTP和DSS应用，并且满足Internet应用的发展需 要，Sybase可以很好地满足关键任务的企业业务应用的需求，提供数据库可靠性、集成性和高性能。ASE有效的多线索结构，内部并行机制和有效的查询优 化技术提供了出色性能和可伸缩性；还可提供先进的企业集成、强健和数据访问与数据移动技术，支持跨越远程Sybase和non-Sybase数据库的分布 事务和查询。ASE进一步扩展了这些功能，通过分布信息和管理商业事务，支持通过企业信息门户对商业系统进行个性化的用户访问。 <br /> MSCS对于诸如电子邮件服务器、数据库应用程序之类的应用程序，是一种良好的运行方式。 <br /> 假设您决定在一个4节点MSCS群集上运行Microsoft Exchange 2000 Server。当安装MSCS软件以及适用于群集的Exchange 2000版本后，您可以对群集进行配置，以便使Exchange 2000能够在主要节点发生故障时在备份节点上进行故障恢复。当故障发生时，主服务器上肯定存在处于打开状态的用户会话，然而，MSCS能够在不丢失任何 数据的情况下快速、自动的完成故障恢复。备份节点将从故障节点上接替工作负载及相关数据，并继续为用户提供服务。 <br /> ICX的最大优点是在数据库集群技术面临的挑战上有了新的探索，此项基于中间件的数据库集群技术为获得具有高可扩性的高性能数据库提供了一条切实可行的途径，同时能灵活地适应未来的技术变化。 <br /> 这种中间件复制技术可位于关键的网络路径上，监听所有进出数据库系统的流量，方便地提供防火墙和其它安 全服务，保护物理的数据库服务器。通过多个服务器的并发处理很容易地隐藏了处理的延迟。实时并行同步交易复制：一旦我们突破了实时并行同步交易复制的技术 障碍，用户就能通过由多个数据库服务器构成的集群来获得高性能，高可用性和高安全性。 <br /> DB2 UDB是一个可以随企业增长的数据库。当对网站的事务需求达到峰值时它可以迅速响应，它可以进行扩展以容纳分布在许多不同数据库中的数量不断增长的信息。 <br /> 随着信息基础结构从一个处理器发展到多个处理器再到高度并行的多个群集，它也随之扩展。将分区技术和群 集技术集成到新的 DB2 UDB Enterprise Server Edition 中意味着该版本很灵活。DB2 UDB还添加了自主数据库技术，它使数据库管理员可以选择使用增强的自动化技术来配置、调优和管理他们的数据库。自主数据库管理意味着管理员可以在管理日 常任务上花费较少的时间。表的多维群集减轻了 DBA 创建索引的工作负担，同时提供了数据群集以快速查询。DB2内置的已规划的和未规划的可用性能力确保了业务应用程序在任何时候都可用。诸如索引重建、索引 创建和表装载之类的联机实用程序以及可以不停止数据库进行更改的配置参数，都意味着改进的性能和高可用性。 <br /> 【相关链接】 <br /> 理想的数据库集群应具备的特点 <br /> 提高速度：只通过简单地增加数据库服务器就能相对提高数据库处理速度。 <br /> 数据同步：在任何时刻需要有多个随时可用的实时同步数据服务。最好有多个异地的同步数据服务。 <br /> 安全保证：除了密码保护之外，我们最好能控制企业内部对数据库的非法访问。 <br /> 可扩展性：应保证我们能任意增大数据集而没有对可用性产生负面影响。 <br /> 一般来说，有关数据库集群的技术都非常庞杂。更具挑战性的是，实际应用要求在提高速度、数据同步、安全保证、可扩展性方面的指标能同时提升，而不是单纯提升某一指标而牺牲其他指标。全面提升这些技术指标是数据库集群技术都将面临的重大课题。 <br /> 【名词解释】 <br /> 集群:是一组通过协同工作方式运行同一套应用程序并针对客户端及应用程序提供单一系统映像的独立计算机。集群技术的目标在于通过多层网络结构进一步提高伸缩能力、可用性与可靠性。 <br /> 可伸缩性:是指一台计算机在维持可接受性能的前提下处理不断提高的工作负载的能力。 <br /> 可用性:是指存在质量、备用能力、获取简便性以及可访问能力。 <br /> 可靠性:是指系统牢固程度。</p> <p class="read-more">Continue reading <a class="heading" href="/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93/2011/05/30/e3-80-90-e8-bd-ac-e3-80-91-e4-b8-bb-e6-b5-81-e6-95-b0-e6-8d-ae-e5-ba-93-e9-9b-86-e7-be-a4-e6-8a-80-e6-9c-af-e6-b7-b1-e5-85-a5-e6-8e-a2-e8-ae-a8.html" data-flip="title">【转】主流数据库集群技术深入探讨</a></p> </article> <h2 class="sr-only">Pagination</h2> <nav class="pagination heading" role="navigation"> <ul> <li class="pagination-item older" > <a rel="next" href="/page-58/">Older</a> </li> <li class="pagination-item newer" > <a rel="prev" href="/page-56/">Newer</a> </li> </ul> </nav> <footer> <hr/> <p>© 2011 - 2017. All rights reserved.</p> <p> <code>Powered by <a href="https://qwtel.com/hydejack/">Hydejack</a> v<span id="_version">6.6.1</span></code> </p> </footer> </main> </div> <div id="_yDrawer"> <div id="_sidebar" class="sidebar"> <div class="sidebar-bg" style="background-color:#4f86aa;background-image:url()"></div> <header class="sidebar-sticky" role="banner"> <div class="sidebar-about"> <img src="https://avatars0.githubusercontent.com/u/4122902?v=4&s=460" class="me" /> </div> <div class="sidebar-about"> <h1><a id="_title" href="/">Ka's Blog</a></h1> <p>Ka’s blog description…</p> </div> <nav class="sidebar-nav heading" role="navigation"> <span class="sr-only">Navigation:</span> <ul> <li> <a class="sidebar-nav-item" href="/categories.html">Categories</a> </li> <li> <a class="sidebar-nav-item" href="/archive.html">Archive</a> </li> <li> <a class="sidebar-nav-item" href="/tags.html">Tags</a> </li> <li> <a class="sidebar-nav-item" href="/about.html">About</a> </li> </ul> </nav> <div class="sidebar-social"> <span class="sr-only">Social:</span> <ul> <li> <a href="https://twitter.com/imhazige" title="Twitter"> <span class="icon-twitter"></span> <span class="sr-only">Twitter</span> </a> </li> <li> <a href="https://github.com/imhazige" title="GitHub"> <span class="icon-github"></span> <span class="sr-only">GitHub</span> </a> </li> <li> <a href="mailto:imhazige@gmail.com" title="Email"> <span class="icon-mail"></span> <span class="sr-only">Email</span> </a> </li> <li> <a href="https://imhazige.github.io/myblog/feed.xml" title="RSS"> <span class="icon-rss2"></span> <span class="sr-only">RSS</span> </a> </li> </ul> </div> </header> </div> </div> </div> <!--[if gt IE 9]><!----> <script>loadJSDeferred('/assets/js/hydejack.js?v=6.6.1');</script> <!--<![endif]--> </body>
</html>
