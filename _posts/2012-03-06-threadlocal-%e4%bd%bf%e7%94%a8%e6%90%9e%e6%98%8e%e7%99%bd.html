---
layout: post
title: ThreadLocal 使用搞明白
date: 2012-03-06 08:17:46.000000000 +00:00
type: post
published: true
status: publish
categories:
- java
tags:
- ThreadLocal
meta:
  views: '168'
author:
  login: ig2net
  email: ig2net@ig2net.info
  display_name: "农夫一号"
  first_name: ''
  last_name: ''
---
<p>我最初使用ThreadLocal是copy Myfaces中的源码，为了保存Httprequest对象，现在想一想，总是听说ThreadLocal是解决并发安全性的好方法，这其中有个道理还是没想清楚：</p>
<p>ThreadLocal只是维护资源副本，因此对本线程资源的改变是不会对其他线程起作用的。</p>
<p>那么我们为什么用它呢，最常用的情况是维护Singleton对象，即一个线程内所有对此对象的访问都可以做到是一个对象，这与类静态变量维护的Sington对象是不同的。</p>
<p>可参考：Hibernate的SessionFactory,IBatis的SqlClient</p>
<p>参见文章:</p>
<p>ThreadLocal如何解决并发安全性 <a href="http://www.java3z.com/cwbwebhome/article/article8/81086.html">http://www.java3z.com/cwbwebhome/article/article8/81086.html</a></p>
<p>&#160;&#160;&#160; 前面我们介绍了Java当中多个线程抢占一个共享资源的问题。但不论是同步还是重入锁，都不能实实在在的解决资源紧缺的情况，这些方案只是靠制定规则来约束线程的行为，让它们不再拼命的争抢，而不是真正从实质上解决他们对资源的需求。   <br />在JDK 1.2当中，引入了java.lang.ThreadLocal。它为我们提供了一种全新的思路来解决线程并发的问题。但是他的名字难免让我们望文生义：本地线程？    <br />什么是本地线程？    <br />本地线程开玩笑的说：不要迷恋哥，哥只是个传说。    <br />&#160;&#160; 其实ThreadLocal并非Thread at Local，而是LocalVariable in a Thread。    <br />根据WikiPedia上的介绍，ThreadLocal其实是源于一项多线程技术，叫做Thread Local Storage，即线程本地存储技术。不仅仅是Java，在C++、C#、.NET、Python、Ruby、Perl等开发平台上，该技术都已经得以实现。</p>
<p><ins><ins></ins></ins></p>
<p>&#160;&#160; 当使用ThreadLocal维护变量时，它会为每个使用该变量的线程提供独立的变量副本。也就是说，他从根本上解决的是资源数量的问题，从而使得每个线程持有相对独立的资源。这样，当多个线程进行工作的时候，它们不需要纠结于同步的问题，于是性能便大大提升。但资源的扩张带来的是更多的空间消耗，ThreadLocal就是这样一种利用空间来换取时间的解决方案。   <br />说了这么多，来看看如何正确使用ThreadLocal。    <br />通过研究JDK文档，我们知道，ThreadLocal中有几个重要的方法：get()、set()、remove()、initailValue()，对应的含义分别是：    <br />返回此线程局部变量的当前线程副本中的值、将此线程局部变量的当前线程副本中的值设置为指定值、移除此线程局部变量当前线程的值、返回此线程局部变量的当前线程的“初始值”。    <br />转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/    <br />还记得我们在第三篇的上半节引出的那个例子么？几个线程修改同一个Student对象中的age属性。为了保证这几个线程能够工作正常，我们需要对Student的对象进行同步。    <br />下面我们对这个程序进行一点小小的改造，我们通过继承Thread来实现多线程：</p>
<p>/**   <br /> *    <br /> * @author x-spirit    <br />*/    <br />public class ThreadDemo3 extends Thread{    <br />private ThreadLocal&lt;Student&gt; stuLocal = new ThreadLocal&lt;Student&gt;();    <br />public ThreadDemo3(Student stu){    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; stuLocal.set(stu);    <br />&#160;&#160;&#160; }    <br />public static void main(String[] args) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Student stu = new Student();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ThreadDemo3 td31 = new ThreadDemo3(stu);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ThreadDemo3 td32 = new ThreadDemo3(stu);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ThreadDemo3 td33 = new ThreadDemo3(stu);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; td31.start();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; td32.start();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; td33.start();    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; @Override    <br />public void run() {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; accessStudent();    <br />&#160;&#160;&#160; }    <br />public void accessStudent() {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; String currentThreadName = Thread.currentThread().getName();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(currentThreadName + &quot; is running!&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Random random = new Random();    <br />int age = random.nextInt(100);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;thread &quot; + currentThreadName + &quot; set age to:&quot; + age);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Student student = stuLocal.get();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; student.setAge(age);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;thread &quot; + currentThreadName + &quot; first&#160; read age is:&quot; + student.getAge());    <br />try {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep(5000);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (InterruptedException ex) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ex.printStackTrace();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;thread &quot; + currentThreadName + &quot; second read age is:&quot; + student.getAge());    <br />&#160;&#160;&#160; }    <br />}</p>
<p>转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/   <br />貌似这个程序没什么问题。但是运行结果却显示：这个程序中的3个线程会抛出3个空指针异常。读者一定感到很困惑。我明明在构造器当中把Student对象set进了ThreadLocal里面阿，为什么run起来之后居然在调用stuLocal.get()方法的时候得到的是NULL呢？    <br />转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/    <br />带着这个疑问，让我们深入到JDK的代码当中，去一看究竟。    <br />转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/    <br />原来，在ThreadLocal中，有一个内部类叫做ThreadLocalMap。这个ThreadLocalMap并非java.util.Map的一个实现，而是利用java.lang.ref.WeakReference实现的一个键-值对应的数据结构其中，key是ThreadLocal类型，而value是Object类型，我们可以简单的视为HashMap&lt;ThreadLocal,Object&gt;。    <br />而在每一个Thread对象中，都有一个ThreadLocalMap的引用，即Thread.threadLocals。而ThreadLocal的set方法就是首先尝试从当前线程中取得ThreadLocalMap（以下简称Map）对象。如果取到的不为null，则以ThreadLocal对象自身为key，来取Map中的value。如果取不到Map对象，则首先为当前线程创建一个ThreadLocalMap，然后以ThreadLocal对象自身为key，将传入的value放入该Map中。</p>
<p>&#160;&#160;&#160; ThreadLocalMap getMap(Thread t) {   <br />return t.threadLocals;    <br />&#160;&#160;&#160; }&#160;&#160;&#160; <br />public void set(T value) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread t = Thread.currentThread();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ThreadLocalMap map = getMap(t);    <br />if (map != null)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; map.set(this, value);    <br />else    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; createMap(t, value);    <br />&#160;&#160;&#160; }</p>
<p>而get方法则是首先得到当前线程的ThreadLocalMap对象，然后，根据ThreadLocal对象自身，取出相应的value。当然，如果在当前线程中取不到ThreadLocalMap对象，则尝试为当前线程创建ThreadLocalMap对象，并以ThreadLocal对象自身为key，把initialValue()方法产生的对象作为value放入新创建的ThreadLocalMap中。</p>
<p>public T get() {   <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread t = Thread.currentThread();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ThreadLocalMap map = getMap(t);    <br />if (map != null) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ThreadLocalMap.Entry e = map.getEntry(this);    <br />if (e != null)    <br />return (T)e.value;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />return setInitialValue();    <br />&#160;&#160;&#160; }    <br />private T setInitialValue() {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; T value = initialValue();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread t = Thread.currentThread();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ThreadLocalMap map = getMap(t);    <br />if (map != null)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; map.set(this, value);    <br />else    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; createMap(t, value);    <br />return value;    <br />&#160;&#160;&#160; }    <br />protected T initialValue() {    <br />return null;    <br />&#160;&#160;&#160; }</p>
<p>这样，我们就明白上面的问题出在哪里：我们在main方法执行期间，试图在调用ThreadDemo3的构造器时向ThreadLocal置入Student对象，而此时，以ThreadLocal对象为key，Student对象为value的Map是被放入当前的活动线程内的。也就是Main线程。而当我们的3个ThreadDemo3线程运行起来以后，调用get()方法，都是试图从当前的活动线程中取得ThreadLocalMap对象，但当前的活动线程显然已经不是Main线程了，于是，程序最终执行了ThreadLocal原生的initialValue()方法，返回了null。   <br />转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/    <br />讲到这里，我想不少朋友一定已经看出来了：ThreadLocal的initialValue()方法是需要被覆盖的。    <br />转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/    <br />于是，ThreadLocal的正确使用方法是：将ThreadLocal以内部类的形式进行继承，并覆盖原来的initialValue()方法，在这里产生可供线程拥有的本地变量值。    <br />这样，我们就有了下面的正确例程：</p>
<p>/**   <br /> *    <br /> * @author x-spirit    <br />*/    <br />public class ThreadDemo3 extends Thread{    <br />private ThreadLocal&lt;Student&gt; stuLocal = new ThreadLocal&lt;Student&gt;(){    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; @Override    <br />protected Student initialValue() {    <br />return new Student();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; };    <br />public ThreadDemo3(){    <br />&#160;&#160;&#160; }    <br />public static void main(String[] args) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ThreadDemo3 td31 = new ThreadDemo3();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ThreadDemo3 td32 = new ThreadDemo3();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ThreadDemo3 td33 = new ThreadDemo3();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; td31.start();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; td32.start();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; td33.start();    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; @Override    <br />public void run() {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; accessStudent();    <br />&#160;&#160;&#160; }    <br />public void accessStudent() {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; String currentThreadName = Thread.currentThread().getName();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(currentThreadName + &quot; is running!&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Random random = new Random();    <br />int age = random.nextInt(100);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;thread &quot; + currentThreadName + &quot; set age to:&quot; + age);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Student student = stuLocal.get();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; student.setAge(age);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;thread &quot; + currentThreadName + &quot; first&#160; read age is:&quot; + student.getAge());    <br />try {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep(5000);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (InterruptedException ex) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ex.printStackTrace();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;thread &quot; + currentThreadName + &quot; second read age is:&quot; + student.getAge());    <br />&#160;&#160;&#160; }    <br />}</p>
<p>可见，要正确使用ThreadLocal，必须注意以下几点：   <br />转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/    <br />1. 总是对ThreadLocal中的initialValue()方法进行覆盖。    <br />转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/    <br />2. 当使用set()或get()方法时牢记这两个方法是对当前活动线程中的ThreadLocalMap进行操作，一定要认清哪个是当前活动线程！    <br />转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/    <br />3. 适当的使用泛型，可以减少不必要的类型转换以及可能由此产生的问题。    <br />转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/    <br />运行该程序，我们发现：程序的执行过程只需要5秒，而如果采用同步的方法，程序的执行结果相同，但执行时间需要15秒。以前是多个线程为了争取一个资源，不得不在同步规则的制约下互相谦让，浪费了一些时间。    <br />转载注明出处：http://x- spirit.javaeye.com/、http: //www.blogjava.net/zhangwei217245/    <br />现在，采用ThreadLocal机制以后，可用的资源多了，你有我有全都有，所以，每个线程都可以毫无顾忌的工作，自然就提高了并发性，线程安全也得以保证。    <br />当今很多流行的开源框架也采用ThreadLocal机制来解决线程的并发问题。比如大名鼎鼎的 Struts 2.x 和 Spring 等。    <br />把ThreadLocal这样的话题放在我们的同步机制探讨中似乎显得不是很合适。但是ThreadLocal的确为我们解决多线程的并发问题带来了全新的思路。它为每个线程创建一个独立的资源副本，从而将多个线程中的数据隔离开来，避免了同步所产生的性能问题，是一种“以空间换时间”的解决方案。    <br />但这并不是说ThreadLocal就是包治百病的万能药了。如果实际的情况不允许我们为每个线程分配一个本地资源副本的话，同步还是非常有意义的。</p>
