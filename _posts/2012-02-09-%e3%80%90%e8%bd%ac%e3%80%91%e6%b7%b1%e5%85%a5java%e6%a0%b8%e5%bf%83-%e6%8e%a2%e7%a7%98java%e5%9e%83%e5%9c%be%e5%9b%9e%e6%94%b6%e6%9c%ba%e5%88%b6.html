---
layout: post
title: "【转】深入Java核心 探秘Java垃圾回收机制"
date: 2012-02-09 10:32:39.000000000 +00:00
type: post
published: true
status: publish
categories:
- java
tags:
- "垃圾回收"
meta:
  views: '18'
author:
  login: ig2net
  email: ig2net@ig2net.info
  display_name: "农夫一号"
  first_name: ''
  last_name: ''
---
<p>转自<a href="http://developer.51cto.com/art/201009/227691.htm">http://developer.51cto.com/art/201009/227691.htm</a></p>
<p>垃圾收集GC（Garbage Collection）是Java语言的核心技术之一，之前我们曾专门探讨过<a href="http://developer.51cto.com/art/200907/138943.htm">Java 7新增的垃圾回收器G1的新特性</a>，但在JVM的内部运行机制上看，Java的垃圾回收原理与机制并未改变。垃圾收集的目的在于清除不再使用的对象。GC通过确定对象是否被活动对象引用来确定是否收集该对象。GC首先要判断该对象是否是时候可以收集。两种常用的方法是引用计数和对象引用遍历。</p>
<p><strong>引用计数收集器</strong></p>
<p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象（不是引用）都有一个引用计数。当一个对象被创建时，且将该对象分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象+1），但当一个对象的某个引用超过了生命周期或者被设置为一个新值时，对象的引用计数减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p>
<p><strong>优点</strong>：引用计数收集器可以很快的执行，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。</p>
<p><strong>缺点</strong>： 无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>
<p><strong>跟踪收集器     <br /></strong>    <br />早期的JVM使用引用计数，现在大多数JVM采用对象引用遍历。对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集。在对象遍历阶段，GC必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象。</p>
<p>下一步，GC要删除不可到达的对象。删除时，有些GC只是简单的扫描堆栈，删除未标记的未标记的对象，并释放它们的内存以生成新的对象，这叫做清除（sweeping）。这种方法的问题在于内存会分成好多小段，而它们不足以用于新的对象，但是组合起来却很大。因此，许多GC可以重新组织内存中的对象，并进行压缩（compact），形成可利用的空间。</p>
<p>为此，GC需要停止其他的活动活动。这种方法意味着所有与应用程序相关的工作停止，只有GC运行。结果，在响应期间增减了许多混杂请求。另外，更复杂的 GC不断增加或同时运行以减少或者清除应用程序的中断。有的GC使用单线程完成这项工作，有的则采用多线程以增加效率。</p>
<p><strong>一些常用的垃圾收集器     <br /></strong>    <br />◆标记－清除收集器    <br />这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存。这种收集器一般使用单线程工作并停止其他操作。并且，由于它只是清除了那些未标记的对象，而并没有对标记对象进行压缩，导致会产生大量内存碎片，从而浪费内存。    <br />◆标记－压缩收集器    <br />有时也叫标记－清除－压缩收集器，与标记－清除收集器有相同的标记阶段。在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈。这种收集器也停止其他操作。</p>
<p><strong>复制收集器     <br /></strong>    <br />这种收集器将堆栈分为两个域，常称为半空间。每次仅使用一半的空间，JVM生成的新对象则放在另一半空间中。GC运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。并且对于指定大小堆来说，需要两倍大小的内存，因为任何时候都只使用其中的一半。</p>
<p><strong>增量收集器     <br /></strong>    <br />增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾，也可理解为把堆栈分成一小块一小块，每次仅对某一个块进行垃圾收集。这会造成较小的应用程序中断时间，使得用户一般不能觉察到垃圾收集器正在工作。</p>
<p><strong>分代收集器     <br /></strong>    <br />复制收集器的缺点是：每次收集时，所有的标记对象都要被拷贝，从而导致一些生命周期很长的对象被来回拷贝多次，消耗大量的时间。而分代收集器则可解决这个问题，分代收集器把堆栈分为两个或多个域，用以存放不同寿命的对象。JVM生成的新对象一般放在其中的某个域中。过一段时间，继续存在的对象(非短命对象)将获得使用期并转入更长寿命的域中。分代收集器对不同的域使用不同的算法以优化性能。</p>
<p><strong>并行收集器     <br /></strong>    <br />并行收集器使用某种传统的算法并使用多线程并行的执行它们的工作。在多CPU机器上使用多线程技术可以显著的提高java应用程序的可扩展性。</p>
<p>最后，贴出一个非常简单的跟踪收集器的例图，以便大家加深对收集器的理解：</p>
<p><a href="http://images.51cto.com/files/uploadimg/20100926/1448090.jpg"><img border="0" alt="跟踪收集器图例" src="{{ site.baseurl }}/assets/1448090.jpg" width="498" height="193" /></a>    <br /><strong>跟踪收集器图例</strong></p>
<p><strong> 使用垃圾收集器要注意的地方     <br /></strong>    <br />下面将提出一些有关垃圾收集器要注意的地方，垃圾收集器知识很多，下面只列出一部分必要的知识：    <br />◆每个对象只能调用finalize(&#160;&#160; )方法一次。如果在finalize(&#160;&#160; )方法执行时产生异常（exception），则该对象仍可以被垃圾收集器收集。    <br />◆垃圾收集器跟踪每一个对象，收集那些不可触及的对象（即该对象不再被程序引用 了），回收其占有的内存空间。但在进行垃圾收集的时候，垃圾收集器会调用该对象的finalize(&#160;&#160; )方法（如果有）。如果在finalize()方法中，又使得该对象被程序引用(俗称复活了)，则该对象就变成了可触及的对象，暂时不会被垃圾收集了。但是由于每个对象只能调用一次finalize(&#160;&#160; )方法，所以每个对象也只可能 &quot;复活 &quot;一次。    <br />◆Java语言允许程序员为任何方法添加finalize(&#160;&#160; )方法，该方法会在垃圾收集器交换回收对象之前被调用。但不要过分依赖该方法对系统资源进行回收和再利用，因为该方法调用后的执行结果是不可预知的。    <br />◆垃圾收集器不可以被强制执行，但程序员可以通过调研System.gc方法来建议执行垃圾收集。记住，只是建议。一般不建议自己写System.gc，因为会加大垃圾收集工作量。</p>
<p>【编辑推荐】</p>
<ol>
<li><a href="http://developer.51cto.com/art/201009/225990.htm">深入Java核心 Java中多态的实现机制</a></li>
<li><a href="http://developer.51cto.com/art/201009/225071.htm">深入Java核心 Java内存分配原理精讲</a></li>
<li><a href="http://developer.51cto.com/art/200906/128967.htm">Java程序员必须了解GC的工作原理</a></li>
<li><a href="http://developer.51cto.com/art/200906/128189.htm">简单理解Java GC与幽灵引用</a></li>
</ol>
