---
layout: post
title: it-e-48 OOP Is Much Better in Theory Than in Practice
date: 2011-07-07 17:25:59.000000000 +01:00
type: post
published: true
status: publish
categories:
- "英语"
tags:
- english
- it
meta:
  views: '18'
author:
  login: ig2net
  email: ig2net@ig2net.info
  display_name: "农夫一号"
  first_name: ''
  last_name: ''
---
<p>Like many ideas that sound good in theory but are clumsy in practice, object-oriented   <br />programming (OOP) offers benefits only in a specialized context—namely, group programming.    <br />And even in that circumstance the benefits are <font color="#0000ff">dubious</font>, though the <font color="#0000ff">proponents</font> of OOP would    <br />have you believe otherwise. Some shops claim OOP success, but many I've spoken with are still    <br />&quot;working on it.&quot; Still trying to get OOP right after ten years? Something strange is going on here.    <br />Certainly for the great majority of programmers—amateurs working alone to create    <br />programs such as a quick sales tax utility for a small business or a geography <font color="#0000ff">quiz</font> for    <br />Junior—the machinery of OOP is almost always far more trouble than it's worth. OOP just    <br />introduces an unnecessary layer of complexity to procedure-oriented design. That's why very few    <br />programming books I've read use OOP techniques (classes, etc.) in their code examples. The    <br />examples are written as functions, not as methods within objects. Programming books are trying    <br />to teach programming—not the primarily <font color="#0000ff">clerical</font> and taxonomic <font color="#0000ff">essence</font> of OOP. Those few    <br />books that do superimpose the OOP mechanisms on their code are, not surprisingly, teaching    <br />about the mysteries of OOP itself.    <br />Of course professional gang programming has specialized requirements. Chief among them    <br />is that the programmers don't step on each other's toes. For instance, a friend who programs for    <br />one of the world's largest software companies told me he knows precisely what he'll be working    <br />on in one year. Obviously, OOP makes sense in such a <font color="#0000ff">bureaucratic</font> system because it needs to be    <br />intensely clerical. Helping to manage large-scale, complex-programming jobs like the one in    <br />which my friend is involved is the primary value of OOP. It's a clerical system with some built-in    <br />security features. In my view, confusing OOP with programming is a mistake.    <br />Contradiction Leads to Confusion    <br />Consider the profound contradiction between the OOP practices of encapsulation and    <br />inheritance. To keep your code bug-free, encapsulation hides procedures (and sometimes even    <br />data) from other programmers and doesn't allow them to edit it. Inheritance then asks these same    <br />programmers to inherit, modify, and reuse this code that they cannot see—they see what goes in    <br />and what comes out, but they must remain ignorant of what's going on inside. In effect, a    <br />programmer with no knowledge of the specific inner workings of your encapsulated class is    <br />asked to reuse it and modify its members. True, OOP includes features to help deal with this    <br />problem, but why does OOP generate problems it must then deal with later?    <br />All this leads to the familiar granularity paradox in OOP: should you create only extremely    <br />small and simple classes for stability (some computer science professors say yes), or should you    <br />make them large and abstract for flexibility (other professors say yes). Which is it?    <br />A frequent argument for OOP is it helps with code reusability, but one can reuse code    <br />without OOP—often by simply copying and pasting. There's no need to superimpose some    <br />elaborate structure of interacting, instantiated objects, with all the messaging and fragility that it</p>
<p>introduces into a program. Further, most programming is done by individuals. Hiding code from   <br />oneself just seems weird. Obviously, some kind of structure must be imposed on people    <br />programming together in groups, but is OOP—with all its baggage and inefficiency—the right    <br />solution?</p>
<p>1, dubious&#160; ['dju:bjəs]   <br />a. 怀疑的,可疑的 </p>
<p>2, proponents&#160;&#160; <br />n. 支持者；建议者（proponent的复数） </p>
<p>3, quiz&#160; [kwiz]   <br />n. 小考,随堂测验,恶作剧     <br />v. 简单测验,恶作剧 </p>
<p>4, clerical&#160; ['klerikəl]   <br />n. 牧师     <br />a. 书记的,事务上的,抄写员的 </p>
<p>5, essence&#160; ['esns]   <br />n. 本质,精髓 </p>
<p>6, bureaucratic&#160; [,bjurəu'krætik]   <br />adj. 官僚的；官僚政治的 </p>
<p>7, intensely&#160;&#160; <br />ad. 强烈地(一心一意地) </p>
