---
layout: post
title: "【转】SSO 原理"
date: 2011-08-16 11:55:03.000000000 +01:00
type: post
published: true
status: publish
categories:
- Web
tags:
- CAS
- sso
meta:
  views: '274'
author:
  login: ig2net
  email: ig2net@ig2net.info
  display_name: "农夫一号"
  first_name: ''
  last_name: ''
---
<p>转载自<a title="http://www.cnblogs.com/yonsin/archive/2009/08/29/1556423.html" href="http://www.cnblogs.com/yonsin/archive/2009/08/29/1556423.html">http://www.cnblogs.com/yonsin/archive/2009/08/29/1556423.html</a>&#160;</p>
<p>&#160;</p>
<p>SSO <span style="font-family: 宋体">是一个非常大的主题，我对这个主题有着深深的感受，自从广州</span> UserGroup <span style="font-family: 宋体">的论坛成立以来，无数网友都在尝试使用开源的</span> CAS <span style="font-family: 宋体">，</span> Kerberos <span style="font-family: 宋体">也提供另外一种方式的</span> SSO <span style="font-family: 宋体">，即基于</span> Windows <span style="font-family: 宋体">域的</span> SSO <span style="font-family: 宋体">，还有就是从</span> 2005 <span style="font-family: 宋体">年开始一直兴旺不衰的</span> SAML <span style="font-family: 宋体">。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">如果将这些免费的</span> SSO <span style="font-family: 宋体">解决方案与商业的</span> Tivoli <span style="font-family: 宋体">或</span> Siteminder <span style="font-family: 宋体">或</span> RSA Secure SSO <span style="font-family: 宋体">产品做对比，差距是存在的。毕竟，商业产品的安全性和用户体验都是无与伦比的，我们现在提到的</span> SSO <span style="font-family: 宋体">，仅仅是</span> Web SSO <span style="font-family: 宋体">，即</span> Web-SSO <span style="font-family: 宋体">是体现在客户端；另外一种</span> SSO <span style="font-family: 宋体">是桌面</span> SSO <span style="font-family: 宋体">，例如，只需要作为</span> Administrator <span style="font-family: 宋体">登录一次</span> windows 2000 <span style="font-family: 宋体">，我便能够在使用</span> MSN/QQ <span style="font-family: 宋体">的时候免去登录的环节</span> ( <span style="font-family: 宋体">注意，这不是用客户端软件的密码记忆功能</span> ) <span style="font-family: 宋体">，是一种代理用户输入密码的功能。因此，桌面</span> SSO <span style="font-family: 宋体">是体现在</span> OS <span style="font-family: 宋体">级别上。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">今天，当我们提起</span> SSO <span style="font-family: 宋体">的时候，我们通常是指</span> Web SSO <span style="font-family: 宋体">，它的主要特点是，</span> SSO <span style="font-family: 宋体">应用之间走</span> Web <span style="font-family: 宋体">协议</span> ( <span style="font-family: 宋体">如</span> HTTP/SSL) <span style="font-family: 宋体">，并且</span> SSO <span style="font-family: 宋体">都只有一个登录入口。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">简单的</span> SSO <span style="font-family: 宋体">的体系中，会有下面三种角色：</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; 1 <span style="font-family: 宋体">，</span> User <span style="font-family: 宋体">（多个）</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; 2 <span style="font-family: 宋体">，</span> Web <span style="font-family: 宋体">应用（多个）</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; 3 <span style="font-family: 宋体">，</span> SSO <span style="font-family: 宋体">认证中心（</span> 1 <span style="font-family: 宋体">个）</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">虽然</span> SSO <span style="font-family: 宋体">实现模式千奇百怪，但万变不离其宗：</span> </p>
<p><span style="font-family: wingdings">l<span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span>Web <span style="font-family: 宋体">应用不处理</span> User <span style="font-family: 宋体">的登录，否则就是多点登陆了，所有的登录都在</span> SSO <span style="font-family: 宋体">认证中心进行。</span> </p>
<p><span style="font-family: wingdings">l<span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span>SSO <span style="font-family: 宋体">认证中心通过一些方法来告诉</span> Web <span style="font-family: 宋体">应用当前访问用户究竟是不是张三</span> / <span style="font-family: 宋体">李四。</span> </p>
<p><span style="font-family: wingdings">l<span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span>SSO <span style="font-family: 宋体">认证中心和所有的</span> Web <span style="font-family: 宋体">应用建立一种信任关系，</span> SSO <span style="font-family: 宋体">认证中心对用户身份正确性的判断会通过某种方法告之</span> Web <span style="font-family: 宋体">应用，而且判断结果必须被</span> Web <span style="font-family: 宋体">应用信任。</span> </p>
<h2 style="margin: 13pt 0cm"><font size="6"><font color="#0000ff"><font face="Arial">2. CAS</font> <span style="font-family: 黑体">的基本原理</span> </font></font></h2>
<p>&#160;&#160;&#160;&#160;&#160;&#160; CAS(Central Authentication Service) <span style="font-family: 宋体">是</span> Yale <span style="font-family: 宋体">大学发起的一个开源项目，据统计，大概每</span> 10 <span style="font-family: 宋体">个采用开源构建</span> Web SSO <span style="font-family: 宋体">的</span> Java <span style="font-family: 宋体">项目，就有</span> 8 <span style="font-family: 宋体">个使用</span> CAS <span style="font-family: 宋体">。对这些统计，我虽然不以为然，但有一点可以肯定的是，</span> CAS <span style="font-family: 宋体">是我认为最简单实效，而且足够安全的</span> SSO <span style="font-family: 宋体">选择。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">本节主要分析</span> CAS <span style="font-family: 宋体">的安全性，以及为什么</span> CAS <span style="font-family: 宋体">被这样设计，带着少许密码学的基础知识，我希望有助于读者对</span> CAS <span style="font-family: 宋体">的协议有更深层次的理解。</span> </p>
<h3 style="margin: 13pt 0cm"><font size="5">2.1 CAS <span style="font-family: 宋体">的结构体系</span> </font></h3>
<p><span style="font-family: 宋体">从结构体系看，</span> CAS <span style="font-family: 宋体">包含两部分：</span> </p>
<p><font color="#0000ff"><span style="font-family: wingdings">l<span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span>CAS Server </font></p>
<p>CAS Server <span style="font-family: 宋体">负责完成对用户的认证工作，</span> CAS Server <span style="font-family: 宋体">需要独立部署，有不止一种</span> CAS Server <span style="font-family: 宋体">的实现，</span> Yale CAS Server <span style="font-family: 宋体">和</span> ESUP CAS Server <span style="font-family: 宋体">都是很不错的选择。</span> </p>
<p>CAS Server <span style="font-family: 宋体">会处理用户名</span> / <span style="font-family: 宋体">密码等凭证</span> (Credentials) <span style="font-family: 宋体">，它可能会到数据库检索一条用户帐号信息，也可能在</span> XML <span style="font-family: 宋体">文件中检索用户密码，对这种方式，</span> CAS <span style="font-family: 宋体">均提供一种灵活但同一的接口</span> / <span style="font-family: 宋体">实现分离的方式，</span> CAS <span style="font-family: 宋体">究竟是用何种认证方式，跟</span> CAS <span style="font-family: 宋体">协议是分离的，也就是，这个认证的实现细节可以自己定制和扩展。</span> </p>
<p><font color="#0000ff"><span style="font-family: wingdings">l<span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span>CAS Client </font></p>
<p>CAS Client <span style="font-family: 宋体">负责部署在客户端（注意，我是指</span> Web <span style="font-family: 宋体">应用），原则上，</span> CAS Client <span style="font-family: 宋体">的部署意味着，当有对本地</span> Web <span style="font-family: 宋体">应用的受保护资源的访问请求，并且需要对请求方进行身份认证，</span> Web <span style="font-family: 宋体">应用不再接受任何的用户名密码等类似的</span> Credentials <span style="font-family: 宋体">，而是重定向到</span> CAS Server <span style="font-family: 宋体">进行认证。</span> </p>
<p><span style="font-family: 宋体">目前，</span> CAS Client <span style="font-family: 宋体">支持（某些在完善中）非常多的客户端，包括</span> Java <span style="font-family: 宋体">、</span> .Net <span style="font-family: 宋体">、</span> ISAPI <span style="font-family: 宋体">、</span> Php <span style="font-family: 宋体">、</span> Perl <span style="font-family: 宋体">、</span> uPortal <span style="font-family: 宋体">、</span> Acegi <span style="font-family: 宋体">、</span> Ruby <span style="font-family: 宋体">、</span> VBScript <span style="font-family: 宋体">等客户端，几乎可以这样说，</span> CAS <span style="font-family: 宋体">协议能够适合任何语言编写的客户端应用。</span> </p>
<h3 style="margin: 13pt 0cm"><font size="5">2.2 CAS <span style="font-family: 宋体">协议</span> </font></h3>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">剖析协议就像剖析设计模式，有些时候，协议让人摸不着头脑。</span> CAS <span style="font-family: 宋体">的代理模式要相对复杂一些，它引入了一些新的概念，我希望能够在这里描述一下其原理，有助于读者在配置和调试</span> CAS SSO <span style="font-family: 宋体">有更清晰的思路。</span> </p>
<p><span style="font-family: 宋体">如果没记错，</span> CAS <span style="font-family: 宋体">协议应该是由</span> <a href="mailto:drew.mazurek@yale.edu"><font color="#ae0405" size="2">Drew Mazurek</font></a> <span style="font-family: 宋体">负责可开发的，从</span> CAS v1 <span style="font-family: 宋体">到现在的</span> CAS v3 <span style="font-family: 宋体">，整个协议的基础思想都是基于</span> Kerberos <span style="font-family: 宋体">的票据方式。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; CAS v1 <span style="font-family: 宋体">非常原始，传送一个用户名居然是</span> ”yes&quot;ndavid.turing” <span style="font-family: 宋体">的方式，</span> CAS v2 <span style="font-family: 宋体">开始使用了</span> XML <span style="font-family: 宋体">规范，大大增强了可扩展性，</span> CAS v3 <span style="font-family: 宋体">开始使用</span> AOP <span style="font-family: 宋体">技术，让</span> Spring <span style="font-family: 宋体">爱好者可以轻松配置</span> CAS Server <span style="font-family: 宋体">到现有的应用环境中。</span> </p>
<p>CAS <span style="font-family: 宋体">是通过</span> TGT(Ticket Granting Ticket) <span style="font-family: 宋体">来获取</span> ST(Service Ticket) <span style="font-family: 宋体">，通过</span> ST <span style="font-family: 宋体">来访问服务，而</span> CAS <span style="font-family: 宋体">也有对应</span> TGT <span style="font-family: 宋体">，</span> ST <span style="font-family: 宋体">的实体，而且他们在保护</span> TGT <span style="font-family: 宋体">的方法上虽然有所区别，但是，最终都可以实现这样一个目的——免去多次登录的麻烦。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">下面，我们看看</span> CAS <span style="font-family: 宋体">的基本协议框架：</span> </p>
<p><strong><font face="MS Sans Serif">2.1.1 </font><span style="font-family: 黑体">基础协议</span> </strong></p>
<p><img border="0" alt="cas_protocol-1.jpg" src="{{ site.baseurl }}/assets/cas_protocol-1.jpg" width="528" height="380" />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; CAS <span style="font-family: 宋体">基础模式</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">上图是一个最基础的</span> CAS <span style="font-family: 宋体">协议，</span> CAS Client <span style="font-family: 宋体">以</span> Filter <span style="font-family: 宋体">方式保护</span> Web <span style="font-family: 宋体">应用的受保护资源，过滤从客户端过来的每一个</span> Web <span style="font-family: 宋体">请求，同时，</span> CAS Client <span style="font-family: 宋体">会分析</span> HTTP <span style="font-family: 宋体">请求中是否包请求</span> Service Ticket( <span style="font-family: 宋体">上图中的</span> Ticket) <span style="font-family: 宋体">，如果没有，则说明该用户是没有经过认证的，于是，</span> CAS Client <span style="font-family: 宋体">会重定向用户请求到</span> CAS Server <span style="font-family: 宋体">（</span> Step 2 <span style="font-family: 宋体">）。</span> Step 3 <span style="font-family: 宋体">是用户认证过程，如果用户提供了正确的</span> Credentials <span style="font-family: 宋体">，</span> CAS Server <span style="font-family: 宋体">会产生一个随机的</span> Service Ticket <span style="font-family: 宋体">，然后，缓存该</span> Ticket <span style="font-family: 宋体">，并且重定向用户到</span> CAS Client <span style="font-family: 宋体">（附带刚才产生的</span> Service Ticket <span style="font-family: 宋体">），</span> Service Ticket <span style="font-family: 宋体">是不可以伪造的，最后，</span> Step 5 <span style="font-family: 宋体">和</span> Step6 <span style="font-family: 宋体">是</span> CAS Client <span style="font-family: 宋体">和</span> CAS Server <span style="font-family: 宋体">之间完成了一个对用户的身份核实，用</span> Ticket <span style="font-family: 宋体">查到</span> Username <span style="font-family: 宋体">，因为</span> Ticket <span style="font-family: 宋体">是</span> CAS Server <span style="font-family: 宋体">产生的，因此，所以</span> CAS Server <span style="font-family: 宋体">的判断是毋庸置疑的。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">该协议完成了一个很简单的任务，就是</span> User(david.turing) <span style="font-family: 宋体">打开</span> IE <span style="font-family: 宋体">，直接访问</span> helloservice <span style="font-family: 宋体">应用，它被立即重定向到</span> CAS Server <span style="font-family: 宋体">进行认证，</span> User <span style="font-family: 宋体">可能感觉到浏览器在</span> helloservcie <span style="font-family: 宋体">和</span> casserver <span style="font-family: 宋体">之间重定向，但</span> User <span style="font-family: 宋体">是看不到，</span> CAS Client <span style="font-family: 宋体">和</span> CAS Server <span style="font-family: 宋体">相互间的</span> Service Ticket <span style="font-family: 宋体">核实</span> (Validation) <span style="font-family: 宋体">过程。当</span> CAS Server <span style="font-family: 宋体">告知</span> CAS Client <span style="font-family: 宋体">用户</span> Service Ticket <span style="font-family: 宋体">对应确凿身份，</span> CAS Client <span style="font-family: 宋体">才会对当前</span> Request <span style="font-family: 宋体">的用户进行服务。</span> </p>
<p><strong><font face="MS Sans Serif">2.2.2 CAS </font><span style="font-family: 黑体">如何实现</span> <font face="MS Sans Serif">SSO</font> </strong></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">当我们的</span> Web <span style="font-family: 宋体">时代还处于初级阶段的时候，</span> SSO <span style="font-family: 宋体">是通过共享</span> cookies <span style="font-family: 宋体">来实现，比如，下面三个域名要做</span> SSO <span style="font-family: 宋体">：</span> </p>
<p><a href="http://www.blogjava.net/"><font color="#ae0405" size="2">http://www.blogjava.net</font></a> </p>
<p><a href="http://www.matrix.org.cn/"><font color="#ae0405" size="2">http://www.matrix.org.cn</font></a> </p>
<p><a href="http://www.csdn.net/"><font color="#ae0405" size="2">http://www.csdn.net</font></a> </p>
<p><span style="font-family: 宋体">如果通过</span> CAS <span style="font-family: 宋体">来集成这三个应用，那么，这三个域名都要做一些域名映射，</span> </p>
<p><a href="http://blogjava.cas.org/"><font color="#ae0405" size="2">http://blogjava.cas.org</font></a> </p>
<p><a href="http://matrix.cas.org/"><font color="#ae0405" size="2">http://matrix.cas.org</font></a> </p>
<p><a href="http://csdn.cas.org/"><font color="#ae0405" size="2">http://csdn.cas.org</font></a> </p>
<p><span style="font-family: 宋体">因为是同一个域，所以每个站点都能够共享基于</span> cas.org <span style="font-family: 宋体">的</span> cookies <span style="font-family: 宋体">。这种方法原始，不灵活而且有不少安全隐患，已经被抛弃了。</span> </p>
<p>CAS <span style="font-family: 宋体">可以很简单的实现跨域的</span> SSO <span style="font-family: 宋体">，因为，单点被控制在</span> CAS Server <span style="font-family: 宋体">，用户最有价值的</span> TGC-Cookie <span style="font-family: 宋体">只是跟</span> CAS Server <span style="font-family: 宋体">相关，</span> CAS Server <span style="font-family: 宋体">就只有一个，因此，解决了</span> cookies <span style="font-family: 宋体">不能跨域的问题。</span> </p>
<p><span style="font-family: 宋体">回到</span> CAS <span style="font-family: 宋体">的基础协议图，当</span> Step3 <span style="font-family: 宋体">完成之后，</span> <font color="#0000ff">CAS Server <span style="font-family: 宋体">会向</span> User <span style="font-family: 宋体">发送一个</span> Ticket granting cookie (TGC) <span style="font-family: 宋体">给</span> User </font><span style="font-family: 宋体"><font color="#0000ff">的浏览器</font>，这个</span> Cookie <span style="font-family: 宋体">就类似</span> Kerberos <span style="font-family: 宋体">的</span> TGT <span style="font-family: 宋体">，下次当用户被</span> Helloservice2 <span style="font-family: 宋体">重定向到</span> CAS Server <span style="font-family: 宋体">的时候，</span> CAS Server <span style="font-family: 宋体">会主动</span> Get <span style="font-family: 宋体">到这个</span> TGC cookie <span style="font-family: 宋体">，然后做下面的事情：</span> </p>
<p>1，<span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="font-family: 宋体">如果</span> User <span style="font-family: 宋体">的持有</span> TGC <span style="font-family: 宋体">且其还没失效，那么就走基础协议图的</span> Step4 <span style="font-family: 宋体">，达到了</span> SSO <span style="font-family: 宋体">的效果。</span> </p>
<p>2，<span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span><span style="font-family: 宋体">如果</span> TGC <span style="font-family: 宋体">失效，那么用户还是要重新认证</span> ( <span style="font-family: 宋体">走基础协议图的</span> Step3) <span style="font-family: 宋体">。</span> </p>
<p><strong><font face="MS Sans Serif">2.2.2 CAS </font><span style="font-family: 黑体">的代理模式</span> </strong></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">模式</span> 1 <span style="font-family: 宋体">已经能够满足大部分简单的</span> SSO <span style="font-family: 宋体">应用，现在，我们探讨一种更复杂的情况，即用户访问</span> helloservice <span style="font-family: 宋体">，</span> helloservice <span style="font-family: 宋体">又依赖于</span> helloservice2 <span style="font-family: 宋体">来获取一些信息，如同：</span> </p>
<p>User <span style="font-family: wingdings">à </span>helloservice <span style="font-family: wingdings">à </span>helloservice2 </p>
<p><span style="font-family: 宋体">这种情况下，假设</span> helloservice2 <span style="font-family: 宋体">也是需要对</span> User <span style="font-family: 宋体">进行身份验证才能访问，那么，为了不影响用户体验（过多的重定向导致</span> User <span style="font-family: 宋体">的</span> IE <span style="font-family: 宋体">窗口不停地</span> <span style="font-family: 宋体">闪动</span> ) <span style="font-family: 宋体">，</span> CAS <span style="font-family: 宋体">引入了一种</span> Proxy <span style="font-family: 宋体">认证机制，即</span> CAS Client <span style="font-family: 宋体">可以代理用户去访问其它</span> Web <span style="font-family: 宋体">应用。</span> </p>
<p><span style="font-family: 宋体">代理的前提是需要</span> CAS Client <span style="font-family: 宋体">拥有用户的身份信息</span> ( <span style="font-family: 宋体">类似凭据</span> ) <span style="font-family: 宋体">。</span> <span style="font-family: 宋体">与其说之前我们提到的</span> TGC <span style="font-family: 宋体">是用户持有对自己身份信息的一种凭据，则这里的</span> PGT <span style="font-family: 宋体">就是</span> CAS Client <span style="font-family: 宋体">端持有的对用户身份信息的一种凭据。凭借</span> TGC <span style="font-family: 宋体">，</span> User <span style="font-family: 宋体">可以免去输入密码以获取访问其它服务的</span> Service Ticket <span style="font-family: 宋体">，所以，这里，凭借</span> PGT <span style="font-family: 宋体">，</span> Web <span style="font-family: 宋体">应用可以代理用户去实现后端的认证，而无需前端用户的参与。</span> </p>
<p><span style="font-family: 宋体">如下面的</span> CAS Proxy <span style="font-family: 宋体">图所示，</span> CAS Client <span style="font-family: 宋体">在基础协议之上，提供了一个额外的</span> PGT URL <span style="font-family: 宋体">给</span> CAS Server, <span style="font-family: 宋体">于是，</span> CAS Server <span style="font-family: 宋体">可以通过</span> PGT URL <span style="font-family: 宋体">提供一个</span> PGT <span style="font-family: 宋体">给</span> CAS Client <span style="font-family: 宋体">。</span>     </p>
<p><img border="0" alt="cas_protocol-2.jpg" src="{{ site.baseurl }}/assets/cas_protocol-2.jpg" width="528" height="402" />     <br />&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">初学者可能会对上图的</span> PGT URL <span style="font-family: 宋体">感到迷惑，或者会问，为什么要这么麻烦，要通过一个额外的</span> URL( <span style="font-family: 宋体">而且是</span> SSL <span style="font-family: 宋体">的入口</span> ) <span style="font-family: 宋体">去传递</span> PGT <span style="font-family: 宋体">？如果直接在</span> Step 6 <span style="font-family: 宋体">返回，则连用来做对应关系的</span> PGTIOU <span style="font-family: 宋体">都可以省掉。</span> PGTIOU <span style="font-family: 宋体">设计是从安全性考虑的，非常必要，</span> CAS <span style="font-family: 宋体">协议安全性问题我会在后面一节介绍。</span> </p>
<p><span style="font-family: 宋体">于是，</span> CAS Client <span style="font-family: 宋体">拿到了</span> PGT( <span style="color: black;font-size: 10pt">PGTIOU-85…..ti2td</span> ) <span style="font-family: 宋体">，这个</span> PGT <span style="font-family: 宋体">跟</span> TGC <span style="font-family: 宋体">同样地关键，</span> CAS Client <span style="font-family: 宋体">可以通过</span> PGT <span style="font-family: 宋体">向后端</span> Web <span style="font-family: 宋体">应用进行认证。如下图所示，</span> Proxy <span style="font-family: 宋体">认证与普通的认证其实差别不大，</span> Step1, 2 <span style="font-family: 宋体">与基础模式的</span> Step 1,2 <span style="font-family: 宋体">几乎一样，唯一不同的是，</span> Proxy <span style="font-family: 宋体">模式用的是</span> PGT <span style="font-family: 宋体">而不是</span> TGC <span style="font-family: 宋体">，是</span> Proxy Ticket <span style="font-family: 宋体">（</span> PT <span style="font-family: 宋体">）而不是</span> Service Ticket <span style="font-family: 宋体">。</span> </p>
<p><span style="font-family: 宋体">最终的结果是，</span> helloservice2 <span style="font-family: 宋体">明白</span> helloservice <span style="font-family: 宋体">所代理的客户是</span> David. Turing <span style="font-family: 宋体">同学，同时，根据本地策略，</span> helloservice2 <span style="font-family: 宋体">有义务为</span> PGTURL=http://helloservice/proxy <span style="font-family: 宋体">服务</span> (PGTURL <span style="font-family: 宋体">用于表示一个</span> Proxy <span style="font-family: 宋体">服务</span> ) <span style="font-family: 宋体">，于是它传递数据给</span> helloservice <span style="font-family: 宋体">。这样，</span> helloservice <span style="font-family: 宋体">便完成一个代理者的角色，协助</span> User <span style="font-family: 宋体">返回他想要的数据。</span> </p>
<p><span style="font-family: 宋体">     <br /><img border="0" alt="cas_protocol-3.jpg" src="{{ site.baseurl }}/assets/cas_protocol-3.jpg" width="543" height="378" />       <br />&#160;&#160; 代理认证模式非常有用，它也是</span> CAS <span style="font-family: 宋体">协议</span> v2 <span style="font-family: 宋体">的一个最大的变化，这种模式非常适合在复杂的业务领域中应用</span> SSO <span style="font-family: 宋体">。因为，以前我们实施</span> SSO <span style="font-family: 宋体">的时候，都是假定以</span> IE User <span style="font-family: 宋体">为</span> SSO <span style="font-family: 宋体">的访问者，忽视了业务系统作为</span> SSO <span style="font-family: 宋体">的访问者角色。</span> </p>
<h3 style="margin: 13pt 0cm"><font size="5">2.3 CAS <span style="font-family: 宋体">安全性</span> </font></h3>
<p>&#160;&#160;&#160;&#160;&#160;&#160; CAS <span style="font-family: 宋体">的安全性是一个非常重要的</span> Topic <span style="font-family: 宋体">。</span> CAS <span style="font-family: 宋体">从</span> v1 <span style="font-family: 宋体">到</span> v3 <span style="font-family: 宋体">，都很依赖于</span> SSL <span style="font-family: 宋体">，它假定了这样一个事实，用户在一个非常不安全的网络环境中使用</span> SSO <span style="font-family: 宋体">，</span> Hacker <span style="font-family: 宋体">的</span> Sniffer <span style="font-family: 宋体">会很容易抓住所有的</span> Http Traffic <span style="font-family: 宋体">，包括通过</span> Http <span style="font-family: 宋体">传送的密码甚至</span> Ticket <span style="font-family: 宋体">票据。</span> </p>
<p><strong><font face="MS Sans Serif">2.3.1 TGC/PGT </font><span style="font-family: 黑体">安全性</span> <font color="#0000ff">[这两个安全性是基础]</font></strong></p>
<div>
<pre />
<p>概念术语<br />
CAS(Central Authentication Service)<br />
TGT(Ticket Granting Ticket)<br />
ST(Service Ticket)<br />
PGT(Proxy Granting Ticket)</p>
<p>&#160;</p>
<p>原理剖析<br />
Yale CAS使用了Ticket Granting Cookie （简称TGC）去作为获取Service Ticket（简称ST）的凭据，这个TGC 是保存在客户端的cookie，即当第2次被其他CAS Client重定向的时候，CAS Server实际上已经从用户的Cookie中抓取到TGC，然后知道TGC对应的用户，因此避免了再次登录，如果CAS Server抓取不到TGC，则用户需要登陆。</p>
<p>众所周知，cookie是不能跨域的。但是CAS能够做abc.com和xyz.com的sso，因为CAS Server缓存了所有的ticket，所以Client无需共享cookies。</p>
<p><font color="#0000ff">似乎CAS设置了一个cas站点的cookie,所以abc.com和xyz.com都是读的cas本域的cookie,因此不存在跨域的问题。</font></p>
</div>
<p></p>
<p><strong><font color="#0000ff">TGC是cookie,TGT也很重要，如果获得了TGT就可以反复使用它来创建ST,直到这个TGT过期。不知为什么不让TGT只有一次使用期限？我测试使用一个TGT可以很长时间获得可用的ST。所以在取TGT和PGT时以及使用TGT和PGT取ST时，都应该使用SSL.</font></strong></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">对于一个</span> CAS <span style="font-family: 宋体">用户来说，最重要是要保护它的</span> TGC <span style="font-family: 宋体">，如果</span> TGC <span style="font-family: 宋体">不慎被</span> CAS Server <span style="font-family: 宋体">以外的实体获得，</span> Hacker <span style="font-family: 宋体">能够找到该</span> TGC <span style="font-family: 宋体">，然后冒充</span> CAS <span style="font-family: 宋体">用户访问所有授权资源。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; SSO <span style="font-family: 宋体">的安全性问题比普通应用的安全性还要严重，因为</span> SSO <span style="font-family: 宋体">存在一种门槛效应。以前即使</span> Hacker <span style="font-family: 宋体">能够截获用户在</span> Web <span style="font-family: 宋体">应用</span> A <span style="font-family: 宋体">的密码，它也未必能知道用户在</span> Web <span style="font-family: 宋体">应用</span> B <span style="font-family: 宋体">的密码，但</span> SSO <span style="font-family: 宋体">让</span> Hacker <span style="font-family: 宋体">只需要截获</span> TGC( <span style="font-family: 宋体">突破了门槛</span> ) <span style="font-family: 宋体">，即能访问所有与该用户相关的所有应用系统。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; PGT <span style="font-family: 宋体">跟</span> TGC <span style="font-family: 宋体">的角色是一样的，如果被</span> Hacker <span style="font-family: 宋体">获得，后果可想而知。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">从基础模式可以看出，</span> TGC <span style="font-family: 宋体">是</span> CAS Server <span style="font-family: 宋体">通过</span> SSL <span style="font-family: 宋体">方式发送给终端用户，因此，要截取</span> TGC <span style="font-family: 宋体">难度非常大，从而确保</span> CAS <span style="font-family: 宋体">的安全性。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">因此，某些人认为</span> CAS <span style="font-family: 宋体">可以不使用</span> SSL <span style="font-family: 宋体">的想法需要更正一下，</span> CAS <span style="font-family: 宋体">的传输安全性仅仅依赖与</span> SSL <span style="font-family: 宋体">。</span> </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">跟</span> Kerberos <span style="font-family: 宋体">一样</span> TGT <span style="font-family: 宋体">，</span> TGC <span style="font-family: 宋体">也有自己的存活周期。下面是</span> CAS <span style="font-family: 宋体">的</span> web.xml <span style="font-family: 宋体">中，通过</span> grantingTimeout <span style="font-family: 宋体">来设置</span> CAS TGC <span style="font-family: 宋体">存活周期的参数，参数默认是</span> 120 <span style="font-family: 宋体">分钟，在合适的范围内设置最小值，太短，会影响</span> SSO <span style="font-family: 宋体">体验，太长，会增加安全性风险。</span> </p>
<table style="border-bottom: medium none;border-left: medium none;margin: auto auto auto 50.4pt;border-collapse: collapse;border-top: medium none;border-right: medium none" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p>&#160;&#160;&#160; &lt;context-param&gt; </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;param-name&gt;edu.yale.its.tp.cas.grantingTimeout&lt;/param-name&gt; </p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; &lt;param-value&gt;7200&lt;/param-value&gt; </p>
<p>&#160;&#160;&#160; &lt;/context-param&gt; </p>
</td>
</tr>
</tbody>
</table>
<p>TGC <span style="font-family: 宋体">面临的风险主要并非传输窃取。比如你登陆了之后，没有</span> Logout <span style="font-family: 宋体">，离开了电脑，别人就可以打开你的浏览器，直接访问你授权访问的应用</span> ) <span style="font-family: 宋体">，设置一个</span> TGC <span style="font-family: 宋体">的有效期，可以减少被别人盗用，或者被</span> Hacker <span style="font-family: 宋体">入侵你的电脑直接获取你系统目录下的</span> TGC Cookie <span style="font-family: 宋体">。</span> </p>
<p><strong><font face="MS Sans Serif">2.3.2 Service Ticket/Proxy Ticket </font><span style="font-family: 黑体">安全性</span> </strong></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">首要明白，</span> Service Ticket <span style="font-family: 宋体">是通过</span> Http <span style="font-family: 宋体">传送的，以为着所网络中的其他人可以</span> Sniffer <span style="font-family: 宋体">到其他人的</span> Ticket <span style="font-family: 宋体">。</span> </p>
<p>CAS <span style="font-family: 宋体">协议从几个方面让</span> Service Ticket <span style="font-family: 宋体">变得更加安全。</span> </p>
<p><span style="font-family: wingdings">l<span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span>Service Ticket <span style="font-family: 宋体">只能使用一次。</span> </p>
<p>CAS <span style="font-family: 宋体">协议规定，无论</span> Service Ticket <span style="font-family: 宋体">验证是否成功，</span> CAS Server <span style="font-family: 宋体">都会将服务端的缓存中清除该</span> Ticket <span style="font-family: 宋体">，从而可以确保一个</span> Service Ticket <span style="font-family: 宋体">被使用两次。</span> </p>
<p><span style="font-family: wingdings">l<span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span>Service Ticket <span style="font-family: 宋体">在一段时间内失效。</span> </p>
<p><span style="font-family: 宋体">假设用户拿到</span> Service Ticket <span style="font-family: 宋体">之后，他请求</span> helloservice <span style="font-family: 宋体">的过程又被中断了，</span> Service Ticket <span style="font-family: 宋体">就被空置了，事实上，此时，</span> Service Ticket <span style="font-family: 宋体">仍然有效。</span> CAS <span style="font-family: 宋体">规定</span> Service Ticket <span style="font-family: 宋体">只能存活一定的时间，然后</span> CAS Server <span style="font-family: 宋体">会让它失效。通过在</span> web.xml <span style="font-family: 宋体">中配置下面的参数，可以让</span> Service Ticket <span style="font-family: 宋体">在多少秒内失效。</span> </p>
<table style="border-bottom: medium none;border-left: medium none;margin: auto auto auto 76.25pt;border-collapse: collapse;border-top: medium none;border-right: medium none" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<p>&lt;context-param&gt; </p>
<p>&lt;param-name&gt;edu.yale.its.tp.cas.serviceTimeout&lt;/param-name&gt; </p>
<p>&lt;param-value&gt;<span style="color: blue">300<font color="#000000">&lt;/param-value&gt;</font></span> </p>
<p>&lt;/context-param&gt; </p>
</td>
</tr>
</tbody>
</table>
<p>&#160;&#160;&#160;&#160;&#160;&#160; <span style="font-family: 宋体">该参数在业务应用的条件范围内，越小越安全。</span> </p>
<p><span style="font-family: wingdings">l<span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </span></span>Service Ticket <span style="font-family: 宋体">是基于随机数生成的。</span> </p>
<p>Service Ticket <span style="font-family: 宋体">必须足够随机，如果</span> Service Ticket <span style="font-family: 宋体">生成规则被猜出（如果你使用了</span> ST+Helloservice+ <span style="font-family: 宋体">自增序列的方式，</span> Hacker <span style="font-family: 宋体">就可以构造下一个</span> Ticket <span style="font-family: 宋体">），</span> Hacker <span style="font-family: 宋体">就等于绕过</span> CAS <span style="font-family: 宋体">认证，直接访问所有服务。</span></p>
