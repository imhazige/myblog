---
layout: post
title: "读书笔记:Effective Java, Second Edition-1,10章"
date: 2011-05-26 05:18:12.000000000 +01:00
type: post
published: true
status: publish
categories:
- java
tags:
- java
- "读书笔记"
meta:
  views: '105'
author:
  login: ig2net
  email: ig2net@ig2net.info
  display_name: "农夫一号"
  first_name: ''
  last_name: ''
---
<p>enum内部实现继承了Enum,所以它不能继承别的类，另外，enum也不能作为别的类的父类。</p>
<p><strong>一 对象构造销毁     <br /></strong></p>
<p><strong>Item 1<strong>用静态方法代替构造器</strong></strong></p>
<p>优点：</p>
<p>不像构造器那样，静态工厂方法拥有名字,可以包含某些意义。</p>
<p>不像构造器那样，每次调用都要创建对象,静态方法可返回可不返回。构造器你要不返回那只有抛个异常了。</p>
<p>不像构造器那样，静态工厂方法可以返回类型的某个子类型。</p>
<p>静态工厂方法可以减少冗长的创建参数化类型时的代码【扯淡，现在还不支持类型推断】</p>
<p>缺点：</p>
<p>一个类在仅提供静态工厂方法，同时没有公共或受保护的构造器时，此类是没法被子类化的。不能很好的使用集成的便利</p>
<p>静态工厂方法和其他的静态方法没什么差别，用户很迷惑，到底是用构造器还是工厂？</p>
<p><strong>Item 2<strong>当构造一个对象需要很多的参数时，建议使用builder方式</strong></strong></p>
<p>最终达到这样的效果：</p>
<p>NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build();</p>
<p>链式调用以及最后的构建方法build产生对象。</p>
<p><strong>Item 3强制单例类的构造器为不可见，或者使用enum来做单例。</strong></p>
<p><strong>Item 4像Utils这样的类也将他的构造器设为不可见，你懂的。</strong></p>
<p><strong>Item 5不要创建不必要的对象</strong></p>
<p>注意节约资源，特别注意循环中的对象创建，注意封箱拆箱可能造成的问题</p>
<p><strong>Item 6内存泄露</strong></p>
<p>public Object pop() {   <br />if (size == 0)    <br />throw new EmptyStackException();    <br />return elements[--size]; //这里应该Object result = elements[--size];elements[size] = null;    <br />}</p>
<p>如果elements不消除的话，虽然减少了一个元素，它是他还在内存中</p>
<p>…… </p>
<p>Item 7<strong>: 避免析构</strong></p>
<p><strong>二 对象通用方法</strong></p>
<p><strong>十 并发</strong></p>
<p><strong>Item 66: 同步访问多线程可修改数据     <br /></strong></p>
<p>如果要同步，读写都需要，否则没什么用处</p>
<p>这样的代码因为没有考虑同步，造成</p>
<p>// Broken! - How long would you expect this program to run?   <br />public class StopThread {    <br />private static boolean stopRequested;    <br />public static void main(String[] args)    <br />throws InterruptedException {    <br />Thread backgroundThread = new Thread(new Runnable() {    <br />public void run() {    <br />int i = 0;    <br />while (!stopRequested) //编译器会优化为while (true),因为stopRequested没有同步    <br />i++;    <br />}    <br />});    <br />backgroundThread.start();    <br />TimeUnit.SECONDS.sleep(1);    <br />stopRequested = true;    <br />}    <br />}</p>
<p><strong>Item 67: Avoid excessive synchronization</strong></p>
<p><strong></strong>同步块内尽量少做事情，特别是不要包含外部代码（及你不知道它做什么的代码，也许这个代码正要使用你的锁对象或其他）</p>
<p>为性能以及设计考虑，尽量不要对你的类进行同步设计，而应该非同步设计，文档告知调用方来让调用方维护同步，例如1.5新加的stringbuilder就是基于这种考虑而取代stringbuffer。例外的情况是静态字段的修改，则要保证同步。因为调用方可以想办法保证一个对象同步，却不能保证一个静态字段的同步。</p>
<p>tip:</p>
<p>CopyOnWriteArrayList这个类是在写的时候其实写的是拷贝的，实际的列表项没有改变，当然“很贵”，我应该不会用它。</p>
<p>多核心同步的花费:</p>
<p>In a multicore world, the real cost of excessive synchronization <strong>is not</strong> the CPU time spent obtaining locks; it is the lost opportunities for <strong>parallelism </strong>and the delays imposed by the need to ensure that every core has a <strong>consistent view</strong> of memory</p>
<p><strong> Item 68: Prefer executors and tasks to threads</strong></p>
<p>1.5开始包含的Executor Framework，queue和异步</p>
<p>创建ExecutorService executor = Executors.newSingleThreadExecutor();   <br />执行executor.execute(runnable);    <br />关闭executor.shutdown();</p>
<p>立即关闭shutdownNow();</p>
<p>但是不要被关闭着两个方法迷惑了，shutdownNow它只是intterupt方法而已，</p>
<p>它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。 </p>
<p>ScheduledThreadPoolExecutor替代java.util.Timer</p>
<p>详见 http://www.iteye.com/topic/366591</p>
<p>总之原来的thread,timer之流在使用时都要考量一番。</p>
<p><strong>Item 69: Prefer concurrency utilities to wait and notify</strong></p>
<p>java.util.concurrent报提供了三个方面的并发&quot;龙套&quot;模块</p>
<p>Executor Framework,</p>
<p>concurrent collections; 并发性能比普通高</p>
<p>synchronizers：线程间协作，等待等CountDownLatch，Semaphore，CyclicBarrier</p>
<p>从名字可以看出，<strong>CountDownLatch</strong>是一个倒数计数的锁，</p>
<p>当倒数到0时触发事件，也就是开锁，其他人就可以进入了。   <br />在一些应用场合中，需要等待某个条件达到要求后才能做后面的事情；同时当线程都完成后也会触发事件，以便进行后面的操作。</p>
<p>CountDownLatch最重要的方法是countDown()和await()，前者主要是倒数一次，后者是等待倒数到0，如果没有到达0，就只有阻塞等待了。</p>
<p>下面的例子简单的说明了CountDownLatch的使用方法，模拟了100米赛跑，10名选手已经准备就绪，只等裁判一声令下。当所有人都到达终点时，比赛结束。</p>
<p>package com.eyesmore.concurrent;   <br />import java.util.concurrent.CountDownLatch;    <br />import java.util.concurrent.ExecutorService;    <br />import java.util.concurrent.Executors;    <br />public class CountDownLatchDemo {    <br />&#160;&#160;&#160; private static final int PLAY_AMOUNT = 10;    <br />&#160;&#160;&#160; public static void main(String[] args) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; /*    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; * 比赛开始：只要裁判说开始，那么所有跑步选手就可以开始跑了    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; * */    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; CountDownLatch begin = new CountDownLatch(1);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; /*    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; * 每个队员跑到末尾时，则报告一个到达，所有人员都到达时，则比赛结束    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; * */    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; CountDownLatch end = new CountDownLatch(PLAY_AMOUNT);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Player[] plays = new Player[PLAY_AMOUNT];    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; for(int i = 0;i&lt;PLAY_AMOUNT;i++) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; plays[i] = new Player(i+1,begin,end);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ExecutorService exe = Executors.newFixedThreadPool(PLAY_AMOUNT);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; for(Player p : plays) {//各就各位    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; exe.execute(p);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;比赛开始&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; begin.countDown();//宣布开始    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; try {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; end.await();//等待结束    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (InterruptedException e) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; e.printStackTrace();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } finally {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;比赛结束&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //注意：此时main线程已经要结束了，但是exe线程如果不关闭是不会结束的    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; exe.shutdown();    <br />&#160;&#160;&#160; }    <br />}    <br />class Player implements Runnable {    <br />&#160;&#160;&#160; private int id;    <br />&#160;&#160;&#160; private CountDownLatch begin;    <br />&#160;&#160;&#160; private CountDownLatch end;    <br />&#160;&#160;&#160; public Player(int id, CountDownLatch begin, CountDownLatch end) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; super();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.id = id;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.begin = begin;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.end = end;    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; public void run() {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; try {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; begin.await();//必须等到裁判countdown到0的时候才开始    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep((long)(Math.random()*100));//模拟跑步需要的时间    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;Play &quot;+id+&quot; has arrived. &quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (InterruptedException e) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; e.printStackTrace();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } finally {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; end.countDown();//向评委报告跑到终点了    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />}</p>
<p>在实际应用中，有时候需要多个线程同时工作以完成同一件事情，而且在完成过程中，往往会等待其他线程都完成某一阶段后再执行，等所有线程都到达某一个阶段后再统一执行。   <br />比如有几个旅行团需要途经深圳、广州、韶关、长沙最后到达武汉。旅行团中有自驾游的，有徒步的，有乘坐旅游大巴的；这些旅行团同时出发，并且每到一个目的地，都要等待其他旅行团到达此地后再同时出发，直到都到达终点站武汉。</p>
<p>这时候<strong>CyclicBarrier</strong>就可以派上用场。CyclicBarrier最重要的属性就是参与者个数，另外最要方法是await()。当所有线程都调用了await()后，就表示这些线程都可以继续执行，否则就会等待。</p>
<p>package examples.ch06.example01;   <br />import java.text.SimpleDateFormat;    <br />import java.util.Date;    <br />import java.util.concurrent.BrokenBarrierException;    <br />import java.util.concurrent.CyclicBarrier;    <br />import java.util.concurrent.ExecutorService;    <br />import java.util.concurrent.Executors;    <br />public class TestCyclicBarrier {    <br />&#160;&#160;&#160; // 徒步需要的时间: Shenzhen, Guangzhou, Shaoguan, Changsha, Wuhan    <br />&#160;&#160;&#160; private static int[] timeWalk = { 5, 8, 15, 15, 10 };    <br />&#160;&#160;&#160; // 自驾游    <br />&#160;&#160;&#160; private static int[] timeSelf = { 1, 3, 4, 4, 5 };    <br />&#160;&#160;&#160; // 旅游大巴    <br />&#160;&#160;&#160; private static int[] timeBus = { 2, 4, 6, 6, 7 };    <br />&#160;&#160;&#160; static String now() {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return sdf.format(new Date()) + &quot;: &quot;;    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; static class Tour implements Runnable {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; private int[] times;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; private CyclicBarrier barrier;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; private String tourName;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public Tour(CyclicBarrier barrier, String tourName, int[] times) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.times = times;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.tourName = tourName;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.barrier = barrier;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public void run() {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; try {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep(times[0] * 1000);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(now() + tourName + &quot; Reached Shenzhen&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; barrier.await();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep(times[1] * 1000);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(now() + tourName + &quot; Reached Guangzhou&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; barrier.await();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep(times[2] * 1000);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(now() + tourName + &quot; Reached Shaoguan&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; barrier.await();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep(times[3] * 1000);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(now() + tourName + &quot; Reached Changsha&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; barrier.await();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep(times[4] * 1000);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(now() + tourName + &quot; Reached Wuhan&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; barrier.await();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (InterruptedException e) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (BrokenBarrierException e) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; public static void main(String[] args) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 三个旅行团    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; CyclicBarrier barrier = new CyclicBarrier(3);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ExecutorService exec = Executors.newFixedThreadPool(3);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; exec.submit(new Tour(barrier, &quot;WalkTour&quot;, timeWalk));    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; exec.submit(new Tour(barrier, &quot;SelfTour&quot;, timeSelf));    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; exec.submit(new Tour(barrier, &quot;BusTour&quot;, timeBus));    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; exec.shutdown();    <br />&#160;&#160;&#160; }    <br />}</p>
<p><strong>Semaphore </strong>信号量，就是一个允许实现设置好的令牌。也许有1个，也许有10个或更多。     <br />谁拿到令牌(acquire)就可以去执行了，如果没有令牌则需要等待。     <br />执行完毕，一定要归还(release)令牌，否则令牌会被很快用光，别的线程就无法获得令牌而执行下去了。</p>
<p>请仔细体会里面关于仓库的处理，</p>
<p>1 是如何保证入库时，如果仓库满就等待，</p>
<p>2 出库时，如果仓库无货就等待的。</p>
<p>3 以及对仓库只有10个库位的处理。</p>
<p>4 对同步问题的处理。</p>
<p>import java.util.concurrent.Semaphore;   <br />/**    <br /> * 老紫竹JAVA提高教程-信号量(Semaphore)的使用。&lt;br&gt;    <br /> * 生产者和消费者的例子，库存的管理。    <br /> *     <br /> * @author 老紫竹(java2000.net,laozizhu.com)    <br /> */    <br />public class TestSemaphore {    <br />&#160; public static void main(String[] args) {    <br />&#160;&#160;&#160; // 启动线程    <br />&#160;&#160;&#160; for (int i = 0; i &lt;= 3; i++) {    <br />&#160;&#160;&#160;&#160;&#160; // 生产者    <br />&#160;&#160;&#160;&#160;&#160; new Thread(new Producer()).start();    <br />&#160;&#160;&#160;&#160;&#160; // 消费者    <br />&#160;&#160;&#160;&#160;&#160; new Thread(new Consumer()).start();    <br />&#160;&#160;&#160; }    <br />&#160; }    <br />&#160; // 仓库    <br />&#160; static Warehouse buffer = new Warehouse();    <br />&#160; // 生产者，负责增加    <br />&#160; static class Producer implements Runnable {    <br />&#160;&#160;&#160; static int num = 1;    <br />&#160;&#160;&#160; @Override    <br />&#160;&#160;&#160; public void run() {    <br />&#160;&#160;&#160;&#160;&#160; int n = num++;    <br />&#160;&#160;&#160;&#160;&#160; while (true) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; try {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; buffer.put(n);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;&gt;&quot; + n);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 速度较快。休息10毫秒    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep(10);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (InterruptedException e) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; e.printStackTrace();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />&#160; }    <br />&#160; // 消费者，负责减少    <br />&#160; static class Consumer implements Runnable {    <br />&#160;&#160;&#160; @Override    <br />&#160;&#160;&#160; public void run() {    <br />&#160;&#160;&#160;&#160;&#160; while (true) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; try {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; System.out.println(&quot;&lt;&quot; + buffer.take());    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 速度较慢，休息1000毫秒    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Thread.sleep(1000);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } catch (InterruptedException e) {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; e.printStackTrace();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />&#160; }    <br />&#160; /**    <br />&#160;&#160; * 仓库    <br />&#160;&#160; *     <br />&#160;&#160; * @author 老紫竹(laozizhu.com)    <br />&#160;&#160; */    <br />&#160; static class Warehouse {    <br />&#160;&#160;&#160; // 非满锁    <br />&#160;&#160;&#160; final Semaphore notFull = new Semaphore(10);    <br />&#160;&#160;&#160; // 非空锁    <br />&#160;&#160;&#160; final Semaphore notEmpty = new Semaphore(0);    <br />&#160;&#160;&#160; // 核心锁    <br />&#160;&#160;&#160; final Semaphore mutex = new Semaphore(1);    <br />&#160;&#160;&#160; // 库存容量    <br />&#160;&#160;&#160; final Object[] items = new Object[10];    <br />&#160;&#160;&#160; int putptr, takeptr, count;    <br />&#160;&#160;&#160; /**    <br />&#160;&#160;&#160;&#160; * 把商品放入仓库.&lt;br&gt;    <br />&#160;&#160;&#160;&#160; *     <br />&#160;&#160;&#160;&#160; * @param x    <br />&#160;&#160;&#160;&#160; * @throws InterruptedException    <br />&#160;&#160;&#160;&#160; */    <br />&#160;&#160;&#160; public void put(Object x) throws InterruptedException {    <br />&#160;&#160;&#160;&#160;&#160; // 保证非满    <br />&#160;&#160;&#160;&#160;&#160; notFull.acquire();    <br />&#160;&#160;&#160;&#160;&#160; // 保证不冲突    <br />&#160;&#160;&#160;&#160;&#160; mutex.acquire();    <br />&#160;&#160;&#160;&#160;&#160; try {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 增加库存    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; items[putptr] = x;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (++putptr == items.length)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; putptr = 0;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; ++count;    <br />&#160;&#160;&#160;&#160;&#160; } finally {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 退出核心区    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; mutex.release();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 增加非空信号量，允许获取商品    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; notEmpty.release();    <br />&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; /**    <br />&#160;&#160;&#160;&#160; * 从仓库获取商品    <br />&#160;&#160;&#160;&#160; *     <br />&#160;&#160;&#160;&#160; * @return    <br />&#160;&#160;&#160;&#160; * @throws InterruptedException    <br />&#160;&#160;&#160;&#160; */    <br />&#160;&#160;&#160; public Object take() throws InterruptedException {    <br />&#160;&#160;&#160;&#160;&#160; // 保证非空    <br />&#160;&#160;&#160;&#160;&#160; notEmpty.acquire();    <br />&#160;&#160;&#160;&#160;&#160; // 核心区    <br />&#160;&#160;&#160;&#160;&#160; mutex.acquire();    <br />&#160;&#160;&#160;&#160;&#160; try {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 减少库存    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; Object x = items[takeptr];    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (++takeptr == items.length)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; takeptr = 0;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; --count;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return x;    <br />&#160;&#160;&#160;&#160;&#160; } finally {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 退出核心区    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; mutex.release();    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // 增加非满的信号量，允许加入商品    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; notFull.release();    <br />&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; }    <br />&#160; }    <br />}</p>
<p>几乎没必要使用wait和notify,notifyAll,他们像是同步的汇编语言，而synchronizers则是提供了上层架构的高级语言。</p>
<p>如果确实需要使用，则牢记同步块中的循环中调用例如：</p>
<p>synchronized (obj) { while (&lt;condition does not hold&gt;) obj.wait(); ... // Perform action appropriate to condition }//这是java doc里面的的范例。</p>
<p>为什么要这样写：</p>
<p>Always use the wait loop idiom to invoke the wait method; never invoke it outside of a loop. The loop serves to test the condition before and after waiting. Testing the condition before waiting and skipping the wait if the condition already holds are necessary to ensure liveness. If the condition already holds and the notify (or notifyAll) method has already been invoked before a thread waits, there is no guarantee that the thread will ever wake from the wait. Testing the condition after waiting and waiting again if the condition does not   <br />hold are necessary to ensure safety. If the thread proceeds with the action when the condition does not hold, it can destroy the invariant guarded by the lock. There are several reasons a thread might wake up when the condition does not hold:</p>
<p>• Another thread could have obtained the lock and changed the guarded state between   <br />the time a thread invoked notify and the time the waiting thread woke.    <br />• Another thread could have invoked notify accidentally or maliciously when    <br />the condition did not hold. Classes expose themselves to this sort of mischief    <br />by waiting on publicly accessible objects. Any wait contained in a synchronized    <br />method of a publicly accessible object is susceptible to this problem.    <br />• The notifying thread could be overly “generous” in waking waiting threads.    <br />For example, the notifying thread might invoke notifyAll even if only some    <br />of the waiting threads have their condition satisfied.    <br />• The waiting thread could (rarely) wake up in the absence of a notify. This is    <br />known as a spurious wakeup [Posix, 11.4.3.6.1; JavaSE6].</p>
<p>并且notifyAll要比notify要好。 </p>
<p>note:</p>
<p>计时用 System.nanoTime()</p>
<p><strong> Item 70: Document thread safety 为你的同步的方法写好文档、注释     <br /></strong></p>
<p><strong>Item 71: Use lazy initialization judiciously 主要讨论了同步情况下的懒加载问题，一般还是建议不需要迟初始化，以免造成并发情况下多次初始化的问题。</strong></p>
<p><strong>Item 72: Don’t depend on the thread scheduler</strong></p>
<p>不要使用Thread.yield,可用sleep代替它。不要使用优先级，这个功能在各虚拟机上表现不一样。yield和优先级都只是暗示，并不意味着虚拟机会执行它们的功能。</p>
<p><strong>Item 73: Avoid thread groups 请用前面提到的线程池而不要使用线程组，线程组你可以忘记他们了，他们是不成功的实现。</strong></p>
