---
layout: post
title: "【转】java nio与tomcat 6 中nio的使用"
date: 2011-06-08 13:41:18.000000000 +01:00
type: post
published: true
status: publish
categories:
- java
tags: []
meta:
  views: '90'
author:
  login: ig2net
  email: ig2net@ig2net.info
  display_name: "农夫一号"
  first_name: ''
  last_name: ''
---
<p class="MsoNormal"><span lang="ZH-CN">转自</span><span style="font-size: 8pt"><a title="http://jiangyongyuan.iteye.com/blog/361983" href="http://jiangyongyuan.iteye.com/blog/361983">http://jiangyongyuan.iteye.com/blog/361983</a> </span></p>
<p class="MsoNormal">
<p>&#160;</p>
<p class="MsoNormal"><span lang="ZH-CN">很早就听说</span>tomcat6<span lang="ZH-CN">使用</span>nio<span lang="ZH-CN">了，这几天突然想到一个问题，使用</span>nio<span lang="ZH-CN">代替传统的</span>bio<span lang="ZH-CN">，</span>ThreadLocal<span lang="ZH-CN">岂不是会存在冲突？</span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN">首先，何谓</span>nio<span lang="ZH-CN">？</span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN">如果读者有</span>socket<span lang="ZH-CN">的编程基础，应该会接触过堵塞</span>socket<span lang="ZH-CN">和非堵塞</span>socket<span lang="ZH-CN">，堵塞</span>socket<span lang="ZH-CN">就是在</span>accept<span lang="ZH-CN">、</span>read<span lang="ZH-CN">、</span>write<span lang="ZH-CN">等</span> IO<span lang="ZH-CN">操作的的时候，如果没有可用符合条件的资源，不马上返回，一直等待直到有资源为止。而非堵塞</span>socket<span lang="ZH-CN">则是在执行</span>select<span lang="ZH-CN">的时候，当没有资源的时候堵塞，当有符合资源的时候，返回一个信号，然后程序就可以执行</span>accept<span lang="ZH-CN">、</span>read<span lang="ZH-CN">、</span>write<span lang="ZH-CN">等操作，这个时候，这些操作是马上完成，并且马上返回。而</span>windows<span lang="ZH-CN">的</span>winsock<span lang="ZH-CN">则有所不同，可以绑定到一个</span>EventHandle<span lang="ZH-CN">里，也可以绑定到一个</span>HWND<span lang="ZH-CN">里，当有资源到达时，发出事件，这时执行的</span>io<span lang="ZH-CN">操作也是马上完成、马上返回的。一般来说，如果使用堵塞</span>socket<span lang="ZH-CN">，通常我们时开一个线程</span>accept socket<span lang="ZH-CN">，当有</span>socket<span lang="ZH-CN">链接的时候，开一个单独的线程处理这个</span>socket<span lang="ZH-CN">；如果使用非堵塞</span>socket<span lang="ZH-CN">，通常是只有一个线程，一开始是</span> select<span lang="ZH-CN">状态，当有信号的时候马上处理，然后继续</span>select<span lang="ZH-CN">状态。</span>     <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN">按照大多数人的说法，堵塞</span>socket<span lang="ZH-CN">比非堵塞</span> socket<span lang="ZH-CN">的性能要好。不过也有小部分人并不是这样认为的，例如</span>Indy<span lang="ZH-CN">项目（</span>Delphi<span lang="ZH-CN">一个比较出色的网络包），它就是使用多线程＋堵塞</span> socket<span lang="ZH-CN">模式的。另外，堵塞</span>socket<span lang="ZH-CN">比非堵塞</span>socket<span lang="ZH-CN">容易理解，符合一般人的思维，编程相对比较容易。</span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN"></span>nio<span lang="ZH-CN">其实也是类似上面的情况。在</span>JDK1.4<span lang="ZH-CN">，</span>sun<span lang="ZH-CN">公司大范围提升</span>Java<span lang="ZH-CN">的性能，其中</span>NIO<span lang="ZH-CN">就是其中一项。</span>Java<span lang="ZH-CN">的</span>IO<span lang="ZH-CN">操作集中在</span>java.io<span lang="ZH-CN">这个包中，是基于流的阻塞</span>API<span lang="ZH-CN">（即</span>BIO<span lang="ZH-CN">，</span>Block IO<span lang="ZH-CN">）。对于大多数应用来说，这样的</span>API<span lang="ZH-CN">使用很方便，然而，一些对性能要求较高的应用，尤其是服务端应用，往往需要一个更为有效的方式来处理</span>IO<span lang="ZH-CN">。从</span> JDK 1.4<span lang="ZH-CN">起，</span>NIO API<span lang="ZH-CN">作为一个基于缓冲区，并能提供非阻塞</span>O<span lang="ZH-CN">操作的</span>API<span lang="ZH-CN">（即</span>NIO<span lang="ZH-CN">，</span>non-blocking IO<span lang="ZH-CN">）被引入。</span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN"></span>BIO<span lang="ZH-CN">与</span>NIO<span lang="ZH-CN">一个比较重要的不同，是我们使用</span>BIO<span lang="ZH-CN">的时候往往会引入多线程，每个连接一个单独的线程；而</span>NIO<span lang="ZH-CN">则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。</span>&#160;&#160; <br /><span lang="ZH-CN"></span>&#160;</p>
<p class="MsoNormal"><a href="http://kazge.com/wp-content/uploads/2011/06/clip_image001.jpg"><img style="border-right-width: 0px;border-top-width: 0px;border-bottom-width: 0px;border-left-width: 0px" border="0" alt="clip_image001" src="{{ site.baseurl }}/assets/clip_image001_thumb.jpg" width="459" height="553" /></a></p>
<p class="MsoNormal">&#160;</p>
<p class="MsoNormal"><span lang="ZH-CN">这个时候，问题就出来了：我们非常多的</span>java<span lang="ZH-CN">应用是使用</span>ThreadLocal<span lang="ZH-CN">的，例如</span>JSF<span lang="ZH-CN">的</span>FaceContext<span lang="ZH-CN">、</span>Hibernate<span lang="ZH-CN">的</span> session<span lang="ZH-CN">管理、</span>Struts2<span lang="ZH-CN">的</span>Context<span lang="ZH-CN">的管理等等，几乎所有框架都或多或少地应用</span>ThreadLocal<span lang="ZH-CN">。如果存在冲突，那岂不惊天动地？</span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN">后来终于在</span>Tomcat6<span lang="ZH-CN">的文档（</span><a href="http://tomcat.apache.org/tomcat-6.0-doc/aio.html">http://tomcat.apache.org/tomcat-6.0-doc/aio.html</a><span lang="ZH-CN">）找到答案。根据上面说明，应该</span>Tomcat6<span lang="ZH-CN">应用</span>nio<span lang="ZH-CN">只是用在处理发送、接收信息的时候用到，也就是说，</span>tomcat6<span lang="ZH-CN">还是传统的多线程</span>Servlet<span lang="ZH-CN">，我画了下面两个图来列出区别：</span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN"></span>tomcat5<span lang="ZH-CN">：客户端连接到达</span> -&gt; <span lang="ZH-CN">传统的</span>SeverSocket.accept<span lang="ZH-CN">接收连接</span> -&gt; <span lang="ZH-CN">从线程池取出一个线程</span> -&gt; <span lang="ZH-CN">在该线程读取文本并且解析</span>HTTP<span lang="ZH-CN">协议</span> -&gt; <span lang="ZH-CN">在该线程生成</span>ServletRequest<span lang="ZH-CN">、</span>ServletResponse<span lang="ZH-CN">，取出请求的</span>Servlet -&gt; <span lang="ZH-CN">在该线程执行这个</span>Servlet -&gt; <span lang="ZH-CN">在该线程把</span>ServletResponse<span lang="ZH-CN">的内容发送到客户端连接</span> -&gt; <span lang="ZH-CN">关闭连接。</span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN">我以前理解的使用</span>nio<span lang="ZH-CN">后的</span>tomcat6<span lang="ZH-CN">：客户端连接到达</span> -&gt; nio<span lang="ZH-CN">接收连接</span> -&gt; nio<span lang="ZH-CN">使用轮询方式读取文本并且解析</span>HTTP<span lang="ZH-CN">协议（单线程）</span> -&gt; <span lang="ZH-CN">生成</span>ServletRequest<span lang="ZH-CN">、</span>ServletResponse<span lang="ZH-CN">，取出请求的</span>Servlet -&gt; <span lang="ZH-CN">直接在本线程执行这个</span>Servlet -&gt; <span lang="ZH-CN">把</span>ServletResponse<span lang="ZH-CN">的内容发送到客户端连接</span> -&gt; <span lang="ZH-CN">关闭连接。</span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN">实际的</span>tomcat6<span lang="ZH-CN">：客户端连接到达</span> -&gt; nio<span lang="ZH-CN">接收连接</span> -&gt; nio<span lang="ZH-CN">使用轮询方式读取文本并且解析</span>HTTP<span lang="ZH-CN">协议（单线程）</span> -&gt; <span lang="ZH-CN">生成</span>ServletRequest<span lang="ZH-CN">、</span>ServletResponse<span lang="ZH-CN">，取出请求的</span>Servlet -&gt; <span lang="ZH-CN"><font color="#0000ff">从线程池取出线程，并在该线程执行这个</font></span><span style="color: #0070c0"><font color="#0000ff">Servlet</font> </span>-&gt; <span lang="ZH-CN">把</span>ServletResponse<span lang="ZH-CN">的内容发送到客户端连接</span> -&gt; <span lang="ZH-CN">关闭连接。</span><span lang="ZH-CN"> </span><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN">从上图可以看出</span><font color="#0000ff"><span style="color: #0070c0">[</span><span lang="ZH-CN">图在哪里</span><span style="color: #0070c0">?</span><span lang="ZH-CN">作者也是转的？</span><span style="color: #0070c0">]</span></font><span lang="ZH-CN">，</span>BIO<span lang="ZH-CN">与</span>NIO<span lang="ZH-CN">的不同，也导致进入客户端处理线程的时刻有所不同：</span>tomcat5<span lang="ZH-CN">在接受连接后马上进入客户端线程，在客户端线程里解析</span>HTTP<span lang="ZH-CN">协议，而</span>tomcat6<span lang="ZH-CN">则是解析完</span>HTTP<span lang="ZH-CN">协议后才进入多线程，另外，</span>tomcat6<span lang="ZH-CN">也比</span>5<span lang="ZH-CN">早脱离客户端线程的环境。</span>&#160; <br /><span lang="ZH-CN"></span>&#160; <br /><span lang="ZH-CN">实际的</span>tomcat6<span lang="ZH-CN">与我之前猜想的差别主要集中在如何处理</span>servlet<span lang="ZH-CN">的问题上。实际上即使抛开</span> ThreadLocal<span lang="ZH-CN">的问题，我之前理解</span>tomcat6<span lang="ZH-CN">只使用一个线程处理的想法其实是行不同的。大家都有经验：</span>servlet<span lang="ZH-CN">是基于</span>BIO<span lang="ZH-CN">的，执行期间会存在堵塞的，例如读取文件、数据库操作等等。</span>tomcat6<span lang="ZH-CN">使用了</span>nio<span lang="ZH-CN">，但不可能要求</span>servlet<span lang="ZH-CN">里面要使用</span>nio<span lang="ZH-CN">，而一旦存在堵塞，效率自然会锐降。</span></p>
